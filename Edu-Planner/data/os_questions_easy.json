[
  {
    "id": 1,
    "topic": "Process Management",
    "question": "Which of the following is NOT a state in the standard process lifecycle?",
    "options": [
      "Running",
      "Blocked",
      "Terminated",
      "Compiled"
    ],
    "answer": "Compiled",
    "explanation": "'Compiled' is a build-time phase, not a runtime process state. Standard states include New, Ready, Running, Waiting/Blocked, and Terminated."
  },
  {
    "id": 2,
    "topic": "Process Management",
    "question": "What is the primary role of the Process Control Block (PCB)?",
    "options": [
      "To store the source code of a process",
      "To manage the user interface of a process",
      "To hold process metadata and execution context",
      "To allocate disk space for process files"
    ],
    "answer": "To hold process metadata and execution context",
    "explanation": "The PCB stores critical information like process ID, CPU registers, program counter, memory limits, and scheduling state."
  },
  {
    "id": 3,
    "topic": "Process Management",
    "question": "What is a zombie process?",
    "options": [
      "A process that consumes excessive CPU cycles",
      "A process that has completed execution but still has an entry in the process table",
      "A process infected by malware",
      "A suspended process waiting for I/O"
    ],
    "answer": "A process that has completed execution but still has an entry in the process table",
    "explanation": "Zombie processes remain in the process table until the parent process reads their exit status via a 'wait' system call."
  },
  {
    "id": 4,
    "topic": "Process Management",
    "question": "Which mechanism allows a parent process to create a new child process?",
    "options": [
      "exec()",
      "fork()",
      "spawn()",
      "clone()"
    ],
    "answer": "fork()",
    "explanation": "In Unix-like systems, fork() creates a child process as a copy of the parent. exec() is often called afterward to replace the child's memory space."
  },
  {
    "id": 5,
    "topic": "Process Management",
    "question": "What is context switching?",
    "options": [
      "Changing the user interface theme",
      "Saving the state of a running process and loading another",
      "Switching between user and kernel mode",
      "Transferring data between processes"
    ],
    "answer": "Saving the state of a running process and loading another",
    "explanation": "Context switching enables multitasking by preserving the CPU state of one process and restoring another’s state."
  },
  {
    "id": 6,
    "topic": "Process Management",
    "question": "Which of the following best describes a daemon process?",
    "options": [
      "A process that runs in the foreground with user interaction",
      "A short-lived system utility",
      "A background process that provides system services",
      "A process that handles only I/O errors"
    ],
    "answer": "A background process that provides system services",
    "explanation": "Daemons (e.g., httpd, sshd) run in the background, detached from terminals, to manage services like web serving or logging."
  },
  {
    "id": 7,
    "topic": "Process Management",
    "question": "What does the 'nice' value of a process influence?",
    "options": [
      "Memory allocation size",
      "Process priority in CPU scheduling",
      "File access permissions",
      "Network bandwidth usage"
    ],
    "answer": "Process priority in CPU scheduling",
    "explanation": "The 'nice' value adjusts a process’s scheduling priority—lower nice values mean higher priority (range typically -20 to +19)."
  },
  {
    "id": 8,
    "topic": "Process Management",
    "question": "Which system call is used to wait for a child process to terminate?",
    "options": [
      "join()",
      "wait()",
      "pause()",
      "yield()"
    ],
    "answer": "wait()",
    "explanation": "The wait() system call allows a parent process to suspend execution until one of its children exits, preventing zombie processes."
  },
  {
    "id": 9,
    "topic": "Process Management",
    "question": "What is the main difference between a process and a thread?",
    "options": [
      "Threads cannot execute code; processes can",
      "Processes share memory by default; threads do not",
      "Threads share the same address space; processes have separate ones",
      "Processes are lighter weight than threads"
    ],
    "answer": "Threads share the same address space; processes have separate ones",
    "explanation": "Threads within a process share code, data, and OS resources, while processes are isolated for protection and stability."
  },
  {
    "id": 10,
    "topic": "Process Management",
    "question": "Which scheduler selects which process should be brought into the ready queue from secondary storage?",
    "options": [
      "Short-term scheduler",
      "Medium-term scheduler",
      "Long-term scheduler",
      "I/O scheduler"
    ],
    "answer": "Long-term scheduler",
    "explanation": "The long-term (or job) scheduler controls the degree of multiprogramming by admitting processes into memory."
  },
  {
    "id": 11,
    "topic": "Process Management",
    "question": "What is process starvation?",
    "options": [
      "A process running out of memory",
      "A process being denied necessary resources indefinitely",
      "A process consuming 100% CPU",
      "A process failing to write to disk"
    ],
    "answer": "A process being denied necessary resources indefinitely",
    "explanation": "Starvation occurs when a low-priority process never gets scheduled due to higher-priority processes monopolizing resources."
  },
  {
    "id": 12,
    "topic": "Process Management",
    "question": "Which of the following is a characteristic of cooperative multitasking?",
    "options": [
      "The OS forcibly preempts processes",
      "Processes voluntarily yield control",
      "Each process runs on a separate CPU core",
      "Scheduling is handled by hardware interrupts"
    ],
    "answer": "Processes voluntarily yield control",
    "explanation": "In cooperative multitasking, processes must explicitly give up the CPU; if one doesn’t, the system can hang."
  },
  {
    "id": 13,
    "topic": "Process Management",
    "question": "What is the purpose of the 'exec' family of system calls?",
    "options": [
      "To terminate a process",
      "To create a new process",
      "To replace the current process image with a new program",
      "To duplicate the current process"
    ],
    "answer": "To replace the current process image with a new program",
    "explanation": "exec() loads a new program into the current process’s memory space, replacing the existing code and data."
  },
  {
    "id": 14,
    "topic": "Process Management",
    "question": "Which of the following is true about orphan processes?",
    "options": [
      "They are automatically deleted by the OS",
      "They are adopted by the init process (PID 1)",
      "They cannot perform I/O operations",
      "They run with root privileges"
    ],
    "answer": "They are adopted by the init process (PID 1)",
    "explanation": "When a parent terminates before its child, the child becomes an orphan and is reparented to init, which eventually reaps it."
  },
  {
    "id": 15,
    "topic": "Process Management",
    "question": "What does the 'ps' command display in Unix-like systems?",
    "options": [
      "Disk partition status",
      "Network socket usage",
      "Currently running processes",
      "Kernel log messages"
    ],
    "answer": "Currently running processes",
    "explanation": "The 'ps' (process status) command shows information about active processes, including PID, CPU usage, and command name."
  },
  {
    "id": 16,
    "topic": "Process Management",
    "question": "Which of the following is NOT a valid reason for process termination?",
    "options": [
      "Normal exit",
      "Fatal error",
      "Parent termination",
      "User changing desktop wallpaper"
    ],
    "answer": "User changing desktop wallpaper",
    "explanation": "Changing wallpaper is a user preference and does not cause process termination. Termination occurs via exit(), signals, or errors."
  },
  {
    "id": 17,
    "topic": "Process Management",
    "question": "What is the role of the dispatcher in process scheduling?",
    "options": [
      "To decide which process runs next",
      "To allocate memory to new processes",
      "To perform context switching and transfer control to the selected process",
      "To monitor CPU temperature"
    ],
    "answer": "To perform context switching and transfer control to the selected process",
    "explanation": "The dispatcher gives control of the CPU to the process selected by the short-term scheduler via context switching."
  },
  {
    "id": 18,
    "topic": "Process Management",
    "question": "Which process state occurs when a process is waiting for an event (e.g., I/O completion)?",
    "options": [
      "Ready",
      "Running",
      "Blocked",
      "New"
    ],
    "answer": "Blocked",
    "explanation": "A blocked (or waiting) process is not eligible for CPU execution until the awaited event occurs."
  },
  {
    "id": 19,
    "topic": "Process Management",
    "question": "What is a race condition in process management?",
    "options": [
      "Two processes competing for CPU time",
      "Unpredictable behavior due to uncontrolled access to shared data",
      "A deadlock between two processes",
      "A process exceeding its time slice"
    ],
    "answer": "Unpredictable behavior due to uncontrolled access to shared data",
    "explanation": "Race conditions occur when the outcome depends on the timing of uncontrollable events, often leading to data corruption."
  },
  {
    "id": 20,
    "topic": "Process Management",
    "question": "Which of the following ensures mutual exclusion in critical sections?",
    "options": [
      "Semaphores",
      "Pipes",
      "Signals",
      "Sockets"
    ],
    "answer": "Semaphores",
    "explanation": "Semaphores are synchronization primitives used to control access to shared resources and prevent race conditions."
  },
  {
    "id": 21,
    "topic": "Process Management",
    "question": "What is the main advantage of multithreading over multiprocessing?",
    "options": [
      "Better security isolation",
      "Lower memory overhead and faster context switching",
      "Easier debugging",
      "Automatic parallelism on single-core CPUs"
    ],
    "answer": "Lower memory overhead and faster context switching",
    "explanation": "Threads share memory and resources, reducing duplication and enabling quicker switches compared to full processes."
  },
  {
    "id": 22,
    "topic": "Process Management",
    "question": "Which scheduling algorithm assigns fixed time slices to each process?",
    "options": [
      "First-Come, First-Served (FCFS)",
      "Shortest Job First (SJF)",
      "Round Robin (RR)",
      "Priority Scheduling"
    ],
    "answer": "Round Robin (RR)",
    "explanation": "Round Robin allocates a fixed time quantum to each ready process in a cyclic order, ensuring fairness."
  },
  {
    "id": 23,
    "topic": "Process Management",
    "question": "What is the convoy effect?",
    "options": [
      "Multiple processes waiting behind a long-running I/O-bound process",
      "A group of processes stuck in deadlock",
      "Short processes delayed behind a long CPU-bound process in FCFS",
      "CPU overheating due to high load"
    ],
    "answer": "Short processes delayed behind a long CPU-bound process in FCFS",
    "explanation": "In FCFS, a long process can hold the CPU, forcing shorter processes to wait, reducing overall efficiency."
  },
  {
    "id": 24,
    "topic": "Process Management",
    "question": "Which of the following is a disadvantage of the Shortest Job First (SJF) algorithm?",
    "options": [
      "It causes frequent context switches",
      "It requires knowledge of future burst times",
      "It favors CPU-bound processes unfairly",
      "It cannot be implemented preemptively"
    ],
    "answer": "It requires knowledge of future burst times",
    "explanation": "SJF needs accurate prediction of CPU burst duration, which is often estimated but not known in advance."
  },
  {
    "id": 25,
    "topic": "Process Management",
    "question": "What is aging in scheduling?",
    "options": [
      "Increasing a process’s memory usage over time",
      "Gradually increasing the priority of waiting processes to prevent starvation",
      "Terminating old processes automatically",
      "Reducing CPU speed for long-running tasks"
    ],
    "answer": "Gradually increasing the priority of waiting processes to prevent starvation",
    "explanation": "Aging boosts the priority of processes that have waited too long, ensuring they eventually get CPU time."
  },
  {
    "id": 26,
    "topic": "Process Management",
    "question": "Which system call is used to send a signal to a process?",
    "options": [
      "kill()",
      "stop()",
      "halt()",
      "abort()"
    ],
    "answer": "kill()",
    "explanation": "The kill() system call sends a specified signal (e.g., SIGTERM, SIGKILL) to a process identified by its PID."
  },
  {
    "id": 27,
    "topic": "Process Management",
    "question": "What is the primary function of the 'init' process in Unix systems?",
    "options": [
      "To compile system software",
      "To manage user logins only",
      "To be the ancestor of all other processes and reap orphans",
      "To format the hard drive at boot"
    ],
    "answer": "To be the ancestor of all other processes and reap orphans",
    "explanation": "Init (PID 1) is the first user-space process started by the kernel and adopts orphaned child processes."
  },
  {
    "id": 28,
    "topic": "Process Management",
    "question": "Which of the following best describes a real-time process?",
    "options": [
      "A process that uses real memory instead of virtual memory",
      "A process that must meet strict timing deadlines",
      "A process that runs only during system idle time",
      "A process that interacts with physical hardware directly"
    ],
    "answer": "A process that must meet strict timing deadlines",
    "explanation": "Real-time processes (hard or soft) require guaranteed response times, common in embedded and control systems."
  },
  {
    "id": 29,
    "topic": "Process Management",
    "question": "What is the purpose of the 'top' command in Linux?",
    "options": [
      "To display the top 10 largest files",
      "To show real-time system and process resource usage",
      "To elevate a process to highest priority",
      "To terminate the most CPU-intensive process"
    ],
    "answer": "To show real-time system and process resource usage",
    "explanation": "The 'top' command provides a dynamic view of running processes, CPU, memory usage, and load averages."
  },
  {
    "id": 30,
    "topic": "Process Management",
    "question": "Which of the following is true about kernel threads?",
    "options": [
      "They exist only in user space",
      "They are managed entirely by user-level libraries",
      "They are scheduled by the OS kernel and can run in kernel mode",
      "They cannot perform system calls"
    ],
    "answer": "They are scheduled by the OS kernel and can run in kernel mode",
    "explanation": "Kernel threads are managed by the OS and can execute kernel code, unlike user-level threads."
  },
  {
    "id": 31,
    "topic": "Process Management",
    "question": "What happens during a process 'fork bomb'?",
    "options": [
      "The system runs out of disk space",
      "A process recursively spawns children until system resources are exhausted",
      "The CPU overheats and shuts down",
      "All network connections are dropped"
    ],
    "answer": "A process recursively spawns children until system resources are exhausted",
    "explanation": "A fork bomb is a denial-of-service attack where a process rapidly creates copies of itself, consuming PIDs and memory."
  },
  {
    "id": 32,
    "topic": "Process Management",
    "question": "Which of the following is NOT a valid process identifier (PID) in Linux?",
    "options": [
      "0",
      "1",
      "100",
      "-5"
    ],
    "answer": "-5",
    "explanation": "PIDs are non-negative integers. PID 0 is the scheduler, PID 1 is init, and others are assigned sequentially."
  },
  {
    "id": 33,
    "topic": "Process Management",
    "question": "What is the main purpose of process synchronization?",
    "options": [
      "To increase CPU clock speed",
      "To coordinate the execution of concurrent processes accessing shared resources",
      "To compress process memory",
      "To encrypt inter-process communication"
    ],
    "answer": "To coordinate the execution of concurrent processes accessing shared resources",
    "explanation": "Synchronization prevents race conditions and ensures data consistency in concurrent environments."
  },
  {
    "id": 34,
    "topic": "Process Management",
    "question": "Which of the following tools can be used to change the priority of a running process?",
    "options": [
      "chmod",
      "renice",
      "mv",
      "grep"
    ],
    "answer": "renice",
    "explanation": "The 'renice' command adjusts the nice value (priority) of an already running process."
  },
  {
    "id": 35,
    "topic": "Process Management",
    "question": "What is a critical section?",
    "options": [
      "A part of code that handles fatal errors",
      "A segment of code that accesses shared resources and must not be concurrently executed",
      "The kernel’s main scheduling loop",
      "A memory region reserved for system crashes"
    ],
    "answer": "A segment of code that accesses shared resources and must not be concurrently executed",
    "explanation": "Critical sections require mutual exclusion to prevent data inconsistency during concurrent access."
  },
  {
    "id": 36,
    "topic": "Process Management",
    "question": "Which scheduling algorithm is most suitable for interactive systems?",
    "options": [
      "FCFS",
      "SJF",
      "Round Robin",
      "Multilevel Queue"
    ],
    "answer": "Round Robin",
    "explanation": "Round Robin provides good response time for interactive processes by using time slicing."
  },
  {
    "id": 37,
    "topic": "Process Management",
    "question": "What does the 'waitpid()' system call allow a parent to do?",
    "options": [
      "Wait for a specific child process",
      "Terminate all child processes",
      "Change the PID of a child",
      "Allocate memory for a child"
    ],
    "answer": "Wait for a specific child process",
    "explanation": "Unlike wait(), waitpid() can wait for a particular child process and supports non-blocking options."
  },
  {
    "id": 38,
    "topic": "Process Management",
    "question": "Which of the following is a benefit of process isolation?",
    "options": [
      "Faster inter-process communication",
      "Reduced memory usage",
      "Improved system stability and security",
      "Automatic load balancing"
    ],
    "answer": "Improved system stability and security",
    "explanation": "Isolation prevents one process from corrupting another’s memory or resources, enhancing reliability."
  },
  {
    "id": 39,
    "topic": "Process Management",
    "question": "What is the role of the 'exit()' system call?",
    "options": [
      "To log out the current user",
      "To terminate the calling process and return a status code",
      "To shut down the entire system",
      "To close all open files"
    ],
    "answer": "To terminate the calling process and return a status code",
    "explanation": "exit() performs cleanup (e.g., flushing buffers) and returns an exit status to the parent process."
  },
  {
    "id": 40,
    "topic": "Process Management",
    "question": "Which of the following is true about lightweight processes (LWP)?",
    "options": [
      "They are the same as kernel threads in many Unix systems",
      "They cannot be scheduled by the OS",
      "They always run in user mode only",
      "They require more memory than regular processes"
    ],
    "answer": "They are the same as kernel threads in many Unix systems",
    "explanation": "LWPs are kernel-supported threads that act as a bridge between user threads and kernel scheduling."
  },
  {
    "id": 41,
    "topic": "Memory Management",
    "question": "What is the main purpose of paging in memory management?",
    "options": [
      "To increase disk storage capacity",
      "To allow non-contiguous allocation of physical memory",
      "To compress program code",
      "To encrypt memory contents"
    ],
    "answer": "To allow non-contiguous allocation of physical memory",
    "explanation": "Paging divides memory into fixed-size blocks (pages/frames), enabling efficient use of physical RAM without requiring contiguous allocation."
  },
  {
    "id": 42,
    "topic": "Memory Management",
    "question": "Which of the following is stored in the page table?",
    "options": [
      "File metadata",
      "Mapping between virtual and physical addresses",
      "CPU register values",
      "Process priority levels"
    ],
    "answer": "Mapping between virtual and physical addresses",
    "explanation": "The page table translates virtual page numbers to physical frame numbers for address resolution."
  },
  {
    "id": 43,
    "topic": "Memory Management",
    "question": "What causes a page fault?",
    "options": [
      "A hardware failure in RAM",
      "Accessing a virtual page not currently in physical memory",
      "Writing to a read-only file",
      "Exceeding CPU temperature limits"
    ],
    "answer": "Accessing a virtual page not currently in physical memory",
    "explanation": "A page fault triggers the OS to load the required page from disk (e.g., swap space) into RAM."
  },
  {
    "id": 44,
    "topic": "Memory Management",
    "question": "Which algorithm replaces the page that has not been used for the longest time?",
    "options": [
      "FIFO",
      "Optimal",
      "LRU",
      "Clock"
    ],
    "answer": "LRU",
    "explanation": "Least Recently Used (LRU) approximates optimal page replacement by evicting the least recently accessed page."
  },
  {
    "id": 45,
    "topic": "Memory Management",
    "question": "What is internal fragmentation?",
    "options": [
      "Unused space within allocated memory blocks",
      "Gaps between memory segments",
      "Corrupted memory pages",
      "Memory leaks due to unreleased pointers"
    ],
    "answer": "Unused space within allocated memory blocks",
    "explanation": "Internal fragmentation occurs when allocated memory is larger than requested (e.g., in fixed-size paging)."
  },
  {
    "id": 46,
    "topic": "Memory Management",
    "question": "What is the purpose of the Translation Lookaside Buffer (TLB)?",
    "options": [
      "To cache disk blocks",
      "To store recently used virtual-to-physical address translations",
      "To buffer keyboard input",
      "To compress memory pages"
    ],
    "answer": "To store recently used virtual-to-physical address translations",
    "explanation": "The TLB is a hardware cache that speeds up virtual address translation by avoiding page table walks."
  },
  {
    "id": 47,
    "topic": "Memory Management",
    "question": "Which memory management technique uses variable-sized partitions?",
    "options": [
      "Paging",
      "Segmentation",
      "Swapping",
      "Caching"
    ],
    "answer": "Segmentation",
    "explanation": "Segmentation divides memory into logical units (e.g., code, data, stack) of varying sizes, unlike fixed-size pages."
  },
  {
    "id": 48,
    "topic": "Memory Management",
    "question": "What is thrashing?",
    "options": [
      "Excessive disk I/O due to constant page swapping",
      "CPU overheating from high load",
      "Memory corruption from buffer overflows",
      "Network congestion from too many processes"
    ],
    "answer": "Excessive disk I/O due to constant page swapping",
    "explanation": "Thrashing occurs when the system spends more time swapping pages than executing useful work, often due to insufficient RAM."
  },
  {
    "id": 49,
    "topic": "Memory Management",
    "question": "Which of the following is a disadvantage of segmentation?",
    "options": [
      "It increases memory access speed",
      "It eliminates external fragmentation",
      "It can lead to external fragmentation",
      "It requires more TLB entries"
    ],
    "answer": "It can lead to external fragmentation",
    "explanation": "Because segments are variable-sized, free memory can become fragmented into small, unusable gaps."
  },
  {
    "id": 50,
    "topic": "Memory Management",
    "question": "What is the role of the 'brk' system call?",
    "options": [
      "To terminate a process",
      "To change the location of the program break (end of heap)",
      "To flush the TLB",
      "To map a file into memory"
    ],
    "answer": "To change the location of the program break (end of heap)",
    "explanation": "brk() and sbrk() adjust the heap size by moving the program break pointer, used by malloc() internally."
  },
  {
    "id": 51,
    "topic": "Memory Management",
    "question": "Which of the following best describes demand paging?",
    "options": [
      "All pages are loaded into memory at process startup",
      "Pages are loaded only when accessed",
      "Pages are pre-fetched based on prediction",
      "Pages are encrypted before loading"
    ],
    "answer": "Pages are loaded only when accessed",
    "explanation": "Demand paging improves memory efficiency by loading pages on first reference, not at program launch."
  },
  {
    "id": 52,
    "topic": "Memory Management",
    "question": "What is a page table entry (PTE)?",
    "options": [
      "A record in the file system",
      "A data structure that holds metadata for a virtual page",
      "A CPU instruction for memory access",
      "A network packet header"
    ],
    "answer": "A data structure that holds metadata for a virtual page",
    "explanation": "Each PTE contains the physical frame number, valid/invalid bit, dirty bit, and protection bits."
  },
  {
    "id": 53,
    "topic": "Memory Management",
    "question": "Which memory allocation strategy allocates the smallest hole that is big enough?",
    "options": [
      "First-fit",
      "Best-fit",
      "Worst-fit",
      "Next-fit"
    ],
    "answer": "Best-fit",
    "explanation": "Best-fit searches for the smallest available partition that can accommodate the request, minimizing wasted space."
  },
  {
    "id": 54,
    "topic": "Memory Management",
    "question": "What is the main advantage of virtual memory?",
    "options": [
      "It increases physical RAM size",
      "It allows programs larger than physical memory to run",
      "It speeds up disk access",
      "It prevents all memory leaks"
    ],
    "answer": "It allows programs larger than physical memory to run",
    "explanation": "Virtual memory uses disk as an extension of RAM, enabling execution of large applications on limited hardware."
  },
  {
    "id": 55,
    "topic": "Memory Management",
    "question": "Which of the following is true about shared memory?",
    "options": [
      "It requires copying data between processes",
      "It is slower than message passing",
      "It allows multiple processes to access the same physical memory region",
      "It is only used for kernel data"
    ],
    "answer": "It allows multiple processes to access the same physical memory region",
    "explanation": "Shared memory is the fastest IPC mechanism since it avoids data copying, but requires synchronization."
  },
  {
    "id": 56,
    "topic": "Memory Management",
    "question": "What does the 'mmap' system call do?",
    "options": [
      "Monitors memory usage",
      "Maps files or devices into the process’s virtual address space",
      "Measures memory bandwidth",
      "Moves memory blocks between processes"
    ],
    "answer": "Maps files or devices into the process’s virtual address space",
    "explanation": "mmap() enables file I/O via memory access, useful for shared memory and efficient large-file handling."
  },
  {
    "id": 57,
    "topic": "Memory Management",
    "question": "Which of the following causes external fragmentation?",
    "options": [
      "Fixed-size memory allocation",
      "Variable-size allocation with deallocation over time",
      "Using virtual memory",
      "Enabling memory protection"
    ],
    "answer": "Variable-size allocation with deallocation over time",
    "explanation": "External fragmentation results in free memory being scattered in small blocks, insufficient for new allocations."
  },
  {
    "id": 58,
    "topic": "Memory Management",
    "question": "What is the purpose of the 'valid' bit in a page table entry?",
    "options": [
      "Indicates if the page is encrypted",
      "Indicates if the page is currently in physical memory",
      "Marks the page as read-only",
      "Shows if the page has been modified"
    ],
    "answer": "Indicates if the page is currently in physical memory",
    "explanation": "If the valid bit is 0, accessing the page triggers a page fault to load it from disk."
  },
  {
    "id": 59,
    "topic": "Memory Management",
    "question": "Which of the following is a benefit of using a multilevel page table?",
    "options": [
      "Faster disk access",
      "Reduced memory overhead for sparse address spaces",
      "Elimination of page faults",
      "Automatic memory compression"
    ],
    "answer": "Reduced memory overhead for sparse address spaces",
    "explanation": "Multilevel page tables avoid allocating page table memory for unused regions of virtual address space."
  },
  {
    "id": 60,
    "topic": "Memory Management",
    "question": "What is copy-on-write (COW)?",
    "options": [
      "A disk backup technique",
      "A method where shared pages are copied only when written to",
      "A memory encryption protocol",
      "A CPU cache invalidation strategy"
    ],
    "answer": "A method where shared pages are copied only when written to",
    "explanation": "COW optimizes fork() by sharing parent and child pages until one modifies them, reducing memory usage."
  },
  {
    "id": 61,
    "topic": "Memory Management",
    "question": "Which of the following is NOT a page replacement algorithm?",
    "options": [
      "LRU",
      "FIFO",
      "SCAN",
      "Clock"
    ],
    "answer": "SCAN",
    "explanation": "SCAN is a disk scheduling algorithm, not a page replacement policy."
  },
  {
    "id": 62,
    "topic": "Memory Management",
    "question": "What is the working set of a process?",
    "options": [
      "The total size of the program on disk",
      "The set of pages actively used during a recent time interval",
      "The number of child processes",
      "The amount of swap space allocated"
    ],
    "answer": "The set of pages actively used during a recent time interval",
    "explanation": "The working set model helps prevent thrashing by ensuring processes have enough frames for active pages."
  },
  {
    "id": 63,
    "topic": "Memory Management",
    "question": "Which system call is used to deallocate memory mapped with mmap()?",
    "options": [
      "free()",
      "munmap()",
      "unmap()",
      "dealloc()"
    ],
    "answer": "munmap()",
    "explanation": "munmap() removes the mapping created by mmap(), freeing the virtual address range."
  },
  {
    "id": 64,
    "topic": "Memory Management",
    "question": "What is memory overcommitment?",
    "options": [
      "Allocating more virtual memory than physical RAM + swap",
      "Using more CPU than available",
      "Exceeding disk quota",
      "Running too many processes"
    ],
    "answer": "Allocating more virtual memory than physical RAM + swap",
    "explanation": "Linux allows overcommitment under the assumption that not all allocated memory will be used simultaneously."
  },
  {
    "id": 65,
    "topic": "Memory Management",
    "question": "Which of the following is true about the heap?",
    "options": [
      "It grows downward from high addresses",
      "It is used for static variables only",
      "It is managed automatically by the compiler",
      "It grows upward and is used for dynamic allocation"
    ],
    "answer": "It grows upward and is used for dynamic allocation",
    "explanation": "The heap expands upward from the end of the data segment and is used for malloc(), new, etc."
  },
  {
    "id": 66,
    "topic": "Memory Management",
    "question": "What is a memory leak?",
    "options": [
      "Physical RAM degradation over time",
      "Failure to deallocate dynamically allocated memory",
      "Unauthorized access to memory",
      "Corrupted page table entries"
    ],
    "answer": "Failure to deallocate dynamically allocated memory",
    "explanation": "Memory leaks occur when allocated memory is not freed, leading to gradual resource exhaustion."
  },
  {
    "id": 67,
    "topic": "Memory Management",
    "question": "Which of the following is used to reduce TLB misses?",
    "options": [
      "Smaller page sizes",
      "Larger page sizes",
      "Disabling virtual memory",
      "Using FIFO replacement"
    ],
    "answer": "Larger page sizes",
    "explanation": "Larger pages (e.g., 2MB or 1GB) cover more address space per TLB entry, reducing misses but increasing internal fragmentation."
  },
  {
    "id": 68,
    "topic": "Memory Management",
    "question": "What is the purpose of the 'dirty' bit in a page table entry?",
    "options": [
      "Indicates the page contains malware",
      "Indicates the page has been modified and needs to be written back to disk",
      "Marks the page as inaccessible",
      "Shows the page is shared"
    ],
    "answer": "Indicates the page has been modified and needs to be written back to disk",
    "explanation": "The dirty bit helps optimize swapping—clean pages can be discarded; dirty pages must be saved."
  },
  {
    "id": 69,
    "topic": "Memory Management",
    "question": "Which memory management unit (MMU) function is critical for virtual memory?",
    "options": [
      "Executing CPU instructions",
      "Translating virtual to physical addresses",
      "Managing disk partitions",
      "Handling network packets"
    ],
    "answer": "Translating virtual to physical addresses",
    "explanation": "The MMU uses page tables to perform address translation, enabling virtual memory abstraction."
  },
  {
    "id": 70,
    "topic": "Memory Management",
    "question": "What is the main drawback of the FIFO page replacement algorithm?",
    "options": [
      "It’s too slow to implement",
      "It can suffer from Belady’s anomaly",
      "It requires hardware support",
      "It doesn’t work with virtual memory"
    ],
    "answer": "It can suffer from Belady’s anomaly",
    "explanation": "Belady’s anomaly means increasing frames can lead to more page faults under FIFO, which is counterintuitive."
  },
  {
    "id": 71,
    "topic": "Memory Management",
    "question": "Which of the following is a characteristic of the stack?",
    "options": [
      "Dynamically allocated with malloc()",
      "Grows upward in memory",
      "Used for function call management and local variables",
      "Shared among all threads in a process"
    ],
    "answer": "Used for function call management and local variables",
    "explanation": "The stack stores return addresses, parameters, and local variables, growing downward with each function call."
  },
  {
    "id": 72,
    "topic": "Memory Management",
    "question": "What is swapping?",
    "options": [
      "Moving entire processes between RAM and disk",
      "Replacing one page with another in RAM",
      "Encrypting memory contents",
      "Compressing inactive pages"
    ],
    "answer": "Moving entire processes between RAM and disk",
    "explanation": "Swapping (in older systems) suspends a process by moving it entirely to swap space to free RAM."
  },
  {
    "id": 73,
    "topic": "Memory Management",
    "question": "Which of the following best describes memory protection?",
    "options": [
      "Preventing processes from accessing unauthorized memory regions",
      "Compressing memory to save space",
      "Backing up memory to cloud storage",
      "Encrypting all RAM contents"
    ],
    "answer": "Preventing processes from accessing unauthorized memory regions",
    "explanation": "Memory protection uses hardware (e.g., MMU) and OS mechanisms to enforce access rights and prevent corruption."
  },
  {
    "id": 74,
    "topic": "Memory Management",
    "question": "What is the role of the 'sbrk' system call?",
    "options": [
      "To change the stack size",
      "To adjust the program break for heap expansion",
      "To flush the CPU cache",
      "To synchronize memory across cores"
    ],
    "answer": "To adjust the program break for heap expansion",
    "explanation": "sbrk() increments or decrements the program break, effectively growing or shrinking the heap."
  },
  {
    "id": 75,
    "topic": "Memory Management",
    "question": "Which of the following is true about virtual address space?",
    "options": [
      "It is limited by physical RAM size",
      "It is the same for all processes",
      "It is private to each process and typically much larger than physical memory",
      "It cannot include memory-mapped files"
    ],
    "answer": "It is private to each process and typically much larger than physical memory",
    "explanation": "Each process has its own virtual address space, giving the illusion of large, contiguous memory."
  },
  {
    "id": 76,
    "topic": "Memory Management",
    "question": "What is a page directory used for?",
    "options": [
      "Storing file names",
      "Indexing disk blocks",
      "In multilevel paging, pointing to page tables",
      "Managing process priorities"
    ],
    "answer": "In multilevel paging, pointing to page tables",
    "explanation": "In x86 architecture, the page directory is the first level of a two-level page table hierarchy."
  },
  {
    "id": 77,
    "topic": "Memory Management",
    "question": "Which of the following reduces external fragmentation?",
    "options": [
      "Paging",
      "Segmentation",
      "Dynamic linking",
      "Shared libraries"
    ],
    "answer": "Paging",
    "explanation": "Because paging uses fixed-size blocks, it eliminates external fragmentation (though internal may remain)."
  },
  {
    "id": 78,
    "topic": "Memory Management",
    "question": "What is the main purpose of memory compaction?",
    "options": [
      "To compress data in RAM",
      "To combine free memory holes into larger blocks",
      "To encrypt memory contents",
      "To reduce CPU cache misses"
    ],
    "answer": "To combine free memory holes into larger blocks",
    "explanation": "Compaction moves allocated blocks to eliminate external fragmentation, but is expensive and rarely used in virtual memory systems."
  },
  {
    "id": 79,
    "topic": "Memory Management",
    "question": "Which of the following is a feature of slab allocation?",
    "options": [
      "Used for managing kernel object caches efficiently",
      "Replaces the need for virtual memory",
      "Allocates memory in powers of two only",
      "Is used exclusively for user-space programs"
    ],
    "answer": "Used for managing kernel object caches efficiently",
    "explanation": "Slab allocation reduces fragmentation and initialization overhead for frequently used kernel objects (e.g., inodes, PCBs)."
  },
  {
    "id": 80,
    "topic": "Memory Management",
    "question": "What happens when the TLB is flushed?",
    "options": [
      "All RAM is erased",
      "The CPU cache is cleared",
      "All virtual-to-physical translations are invalidated",
      "The page file is deleted"
    ],
    "answer": "All virtual-to-physical translations are invalidated",
    "explanation": "TLB flush occurs during context switches or page table changes, causing subsequent memory accesses to miss until reloaded."
  },
  {
    "id": 81,
    "topic": "File Systems",
    "question": "What is the primary purpose of an inode in Unix-like file systems?",
    "options": [
      "To store the file name",
      "To store file metadata and pointers to data blocks",
      "To manage disk partitions",
      "To cache directory entries"
    ],
    "answer": "To store file metadata and pointers to data blocks",
    "explanation": "Inodes contain file size, permissions, timestamps, and block pointers, but not the file name (stored in directory entries)."
  },
  {
    "id": 82,
    "topic": "File Systems",
    "question": "Which file system structure maps file names to inodes?",
    "options": [
      "Superblock",
      "Directory",
      "Page cache",
      "Buffer pool"
    ],
    "answer": "Directory",
    "explanation": "A directory is a special file that contains (filename, inode number) pairs, enabling name-to-inode resolution."
  },
  {
    "id": 83,
    "topic": "File Systems",
    "question": "What is a hard link?",
    "options": [
      "A pointer to another file’s path",
      "A duplicate copy of a file",
      "An additional directory entry pointing to the same inode",
      "A compressed version of a file"
    ],
    "answer": "An additional directory entry pointing to the same inode",
    "explanation": "Hard links share the same inode and data blocks; deleting one doesn’t affect the other until link count reaches zero."
  },
  {
    "id": 84,
    "topic": "File Systems",
    "question": "Which of the following is true about symbolic (soft) links?",
    "options": [
      "They share the same inode as the target file",
      "They cannot cross file system boundaries",
      "They become invalid if the target is deleted",
      "They increase the inode’s link count"
    ],
    "answer": "They become invalid if the target is deleted",
    "explanation": "Symbolic links store the target path as a string; if the target is removed, the link becomes a 'dangling' pointer."
  },
  {
    "id": 85,
    "topic": "File Systems",
    "question": "What does the 'superblock' contain?",
    "options": [
      "User passwords",
      "Metadata about the file system (size, block count, free blocks, etc.)",
      "The root directory contents",
      "Kernel module parameters"
    ],
    "answer": "Metadata about the file system (size, block count, free blocks, etc.)",
    "explanation": "The superblock is critical for file system integrity and is loaded into memory when the file system is mounted."
  },
  {
    "id": 86,
    "topic": "File Systems",
    "question": "Which file allocation method suffers from external fragmentation?",
    "options": [
      "Contiguous allocation",
      "Linked allocation",
      "Indexed allocation",
      "None of the above"
    ],
    "answer": "Contiguous allocation",
    "explanation": "Contiguous allocation requires a single continuous block, leading to external fragmentation as files are created and deleted."
  },
  {
    "id": 87,
    "topic": "File Systems",
    "question": "What is the main advantage of journaling file systems (e.g., ext3, ext4)?",
    "options": [
      "Faster file compression",
      "Improved recovery after crashes by logging changes before committing",
      "Automatic file encryption",
      "Reduced disk space usage"
    ],
    "answer": "Improved recovery after crashes by logging changes before committing",
    "explanation": "Journaling records metadata changes in a log, allowing quick rollback or replay after system failure."
  },
  {
    "id": 88,
    "topic": "File Systems",
    "question": "Which system call creates a new directory?",
    "options": [
      "mkdir()",
      "create()",
      "makedir()",
      "newdir()"
    ],
    "answer": "mkdir()",
    "explanation": "mkdir() creates a new empty directory with specified permissions."
  },
  {
    "id": 89,
    "topic": "File Systems",
    "question": "What is the purpose of the 'fsck' utility?",
    "options": [
      "To format a disk",
      "To check and repair file system inconsistencies",
      "To mount a file system",
      "To compress files"
    ],
    "answer": "To check and repair file system inconsistencies",
    "explanation": "fsck (file system check) scans for and fixes errors in metadata structures like inodes and block bitmaps."
  },
  {
    "id": 90,
    "topic": "File Systems",
    "question": "Which of the following is a characteristic of the FAT file system?",
    "options": [
      "Uses inodes for file metadata",
      "Employs a File Allocation Table to track cluster chains",
      "Supports advanced permissions and journaling",
      "Is case-sensitive by default"
    ],
    "answer": "Employs a File Allocation Table to track cluster chains",
    "explanation": "FAT uses a table where each entry points to the next cluster in a file, forming a linked list."
  },
  {
    "id": 91,
    "topic": "File Systems",
    "question": "What is a mount point?",
    "options": [
      "A hardware connector for disks",
      "A directory where a file system is attached to the directory tree",
      "A type of disk partition",
      "A backup location for files"
    ],
    "answer": "A directory where a file system is attached to the directory tree",
    "explanation": "Mounting integrates a file system (e.g., from a USB drive) into the existing directory hierarchy at the mount point."
  },
  {
    "id": 92,
    "topic": "File Systems",
    "question": "Which of the following is NOT a standard file type in Unix?",
    "options": [
      "Regular file",
      "Directory",
      "Symbolic link",
      "Compressed archive"
    ],
    "answer": "Compressed archive",
    "explanation": "Compressed archives are regular files with special content; Unix file types include regular, directory, symlink, block/char device, FIFO, socket."
  },
  {
    "id": 93,
    "topic": "File Systems",
    "question": "What does the 'umask' command control?",
    "options": [
      "Disk usage limits",
      "Default file permissions for newly created files",
      "Maximum file size",
      "Network file sharing settings"
    ],
    "answer": "Default file permissions for newly created files",
    "explanation": "umask specifies which permission bits to disable (e.g., umask 022 results in rw-r--r-- for files)."
  },
  {
    "id": 94,
    "topic": "File Systems",
    "question": "Which of the following best describes a sparse file?",
    "options": [
      "A file with no metadata",
      "A file that appears larger than its actual disk usage due to unallocated blocks",
      "A highly compressed file",
      "A file stored in RAM only"
    ],
    "answer": "A file that appears larger than its actual disk usage due to unallocated blocks",
    "explanation": "Sparse files contain 'holes' (blocks never written), saving disk space while maintaining logical size."
  },
  {
    "id": 95,
    "topic": "File Systems",
    "question": "What is the role of the 'dentry' cache in Linux?",
    "options": [
      "Caches disk block data",
      "Caches directory entry to inode mappings for faster path resolution",
      "Stores file content in memory",
      "Manages swap space"
    ],
    "answer": "Caches directory entry to inode mappings for faster path resolution",
    "explanation": "The dentry cache speeds up file access by remembering the mapping from path components to inodes."
  },
  {
    "id": 96,
    "topic": "File Systems",
    "question": "Which system call is used to delete a file?",
    "options": [
      "delete()",
      "remove()",
      "unlink()",
      "erase()"
    ],
    "answer": "unlink()",
    "explanation": "unlink() removes a directory entry and decrements the inode’s link count; the file is deleted when count reaches zero."
  },
  {
    "id": 97,
    "topic": "File Systems",
    "question": "What is the maximum file size in a file system with 4KB blocks and a single indirect block pointer?",
    "options": [
      "4KB",
      "4MB",
      "4GB",
      "Depends on pointer size"
    ],
    "answer": "Depends on pointer size",
    "explanation": "If each block holds N pointers (e.g., 1024 for 4-byte pointers in 4KB block), max size = N × block size. So ~4MB for 32-bit pointers."
  },
  {
    "id": 98,
    "topic": "File Systems",
    "question": "Which of the following is a benefit of using B-trees in file systems (e.g., NTFS, ext4 extents)?",
    "options": [
      "Faster sequential reads",
      "Efficient indexing of large directories or file extents",
      "Reduced need for inodes",
      "Automatic file compression"
    ],
    "answer": "Efficient indexing of large directories or file extents",
    "explanation": "B-trees maintain sorted data and allow logarithmic-time searches, insertions, and deletions, ideal for large datasets."
  },
  {
    "id": 99,
    "topic": "File Systems",
    "question": "What is the purpose of the 'sync' system call?",
    "options": [
      "To synchronize file names across networks",
      "To flush file system buffers to disk",
      "To create a file backup",
      "To encrypt file contents"
    ],
    "answer": "To flush file system buffers to disk",
    "explanation": "sync() ensures all pending modifications to file system metadata and data are written to storage."
  },
  {
    "id": 100,
    "topic": "File Systems",
    "question": "Which of the following is true about file descriptors?",
    "options": [
      "They are global across all processes",
      "They are indices into a per-process file descriptor table",
      "They store file content",
      "They are the same as inodes"
    ],
    "answer": "They are indices into a per-process file descriptor table",
    "explanation": "Each process has its own FD table; FD 0, 1, 2 are typically stdin, stdout, stderr."
  },
  {
    "id": 101,
    "topic": "File Systems",
    "question": "What is an access control list (ACL)?",
    "options": [
      "A list of recently accessed files",
      "A mechanism to define fine-grained file permissions beyond owner/group/others",
      "A log of file system errors",
      "A cache of directory entries"
    ],
    "answer": "A mechanism to define fine-grained file permissions beyond owner/group/others",
    "explanation": "ACLs allow specifying permissions for individual users or groups, offering more flexibility than traditional Unix permissions."
  },
  {
    "id": 102,
    "topic": "File Systems",
    "question": "Which command lists disk usage of files and directories?",
    "options": [
      "df",
      "du",
      "ls",
      "fdisk"
    ],
    "answer": "du",
    "explanation": "'du' (disk usage) reports the amount of disk space used by files and directories."
  },
  {
    "id": 103,
    "topic": "File Systems",
    "question": "What is the main difference between hard and soft links regarding file system boundaries?",
    "options": [
      "Hard links can cross file systems; soft links cannot",
      "Soft links can cross file systems; hard links cannot",
      "Both can cross file systems",
      "Neither can cross file systems"
    ],
    "answer": "Soft links can cross file systems; hard links cannot",
    "explanation": "Hard links require the same inode, which is file system-specific; soft links use paths and can point anywhere."
  },
  {
    "id": 104,
    "topic": "File Systems",
    "question": "Which of the following is stored in a directory entry in ext4?",
    "options": [
      "File content",
      "File permissions",
      "File name and inode number",
      "Creation time"
    ],
    "answer": "File name and inode number",
    "explanation": "Directory entries map human-readable names to inode numbers; metadata resides in the inode."
  },
  {
    "id": 105,
    "topic": "File Systems",
    "question": "What is the purpose of the 'lost+found' directory?",
    "options": [
      "To store user-deleted files",
      "To hold orphaned files recovered by fsck after a crash",
      "To cache temporary files",
      "To log file access attempts"
    ],
    "answer": "To hold orphaned files recovered by fsck after a crash",
    "explanation": "If inodes are found with no directory links, fsck places them in lost+found for administrator review."
  },
  {
    "id": 106,
    "topic": "File Systems",
    "question": "Which file system feature allows a file to be extended without rewriting existing data?",
    "options": [
      "Journaling",
      "Extents",
      "Compression",
      "Encryption"
    ],
    "answer": "Extents",
    "explanation": "Extents represent contiguous block ranges, reducing metadata overhead and simplifying file growth."
  },
  {
    "id": 107,
    "topic": "File Systems",
    "question": "What does the 'stat' system call return?",
    "options": [
      "File content",
      "File metadata (size, permissions, timestamps, etc.)",
      "Directory listing",
      "Disk partition info"
    ],
    "answer": "File metadata (size, permissions, timestamps, etc.)",
    "explanation": "stat() retrieves detailed information about a file, including inode number, size, and access/modification times."
  },
  {
    "id": 108,
    "topic": "File Systems",
    "question": "Which of the following is a limitation of the FAT32 file system?",
    "options": [
      "Maximum file size of 4GB",
      "No support for directories",
      "Case-sensitive file names",
      "Requires journaling"
    ],
    "answer": "Maximum file size of 4GB",
    "explanation": "FAT32 uses 32-bit file sizes, limiting individual files to just under 4GB (2^32 - 1 bytes)."
  },
  {
    "id": 109,
    "topic": "File Systems",
    "question": "What is the role of the 'block bitmap' in a file system?",
    "options": [
      "Tracks which blocks are free or allocated",
      "Stores file names",
      "Caches disk reads",
      "Manages user permissions"
    ],
    "answer": "Tracks which blocks are free or allocated",
    "explanation": "The block bitmap is a data structure where each bit represents the allocation status of a disk block."
  },
  {
    "id": 110,
    "topic": "File Systems",
    "question": "Which system call changes the current working directory?",
    "options": [
      "chdir()",
      "cd()",
      "movedir()",
      "setdir()"
    ],
    "answer": "chdir()",
    "explanation": "chdir() updates the process’s current working directory, affecting relative path resolution."
  },
  {
    "id": 111,
    "topic": "File Systems",
    "question": "What is metadata in the context of file systems?",
    "options": [
      "The actual content of a file",
      "Data about the file (e.g., size, owner, permissions)",
      "Encrypted file headers",
      "Network transmission data"
    ],
    "answer": "Data about the file (e.g., size, owner, permissions)",
    "explanation": "Metadata describes the file’s properties and is stored separately from its content (e.g., in inodes)."
  },
  {
    "id": 112,
    "topic": "File Systems",
    "question": "Which of the following is true about the root directory?",
    "options": [
      "It has no parent directory",
      "It is stored in RAM only",
      "It can be deleted by the root user",
      "It is optional in Unix systems"
    ],
    "answer": "It has no parent directory",
    "explanation": "The root directory ('/') is the top of the file system hierarchy and has no parent."
  },
  {
    "id": 113,
    "topic": "File Systems",
    "question": "What is the purpose of the 'lseek' system call?",
    "options": [
      "To search for a file",
      "To move the file offset pointer for read/write operations",
      "To lock a file for exclusive access",
      "To list directory contents"
    ],
    "answer": "To move the file offset pointer for read/write operations",
    "explanation": "lseek() repositions the read/write pointer within an open file, enabling random access."
  },
  {
    "id": 114,
    "topic": "File Systems",
    "question": "Which file system is commonly used on CDs and DVDs?",
    "options": [
      "ext4",
      "NTFS",
      "ISO 9660",
      "HFS+"
    ],
    "answer": "ISO 9660",
    "explanation": "ISO 9660 is a standard file system for optical disc media, supporting cross-platform compatibility."
  },
  {
    "id": 115,
    "topic": "File Systems",
    "question": "What is a file handle?",
    "options": [
      "A physical grip on a storage device",
      "An abstract reference to an open file used by the OS",
      "A user password for file access",
      "A compressed file format"
    ],
    "answer": "An abstract reference to an open file used by the OS",
    "explanation": "File handles (or descriptors) allow programs to perform I/O without knowing internal file system details."
  },
  {
    "id": 116,
    "topic": "File Systems",
    "question": "Which command is used to check available disk space?",
    "options": [
      "du",
      "df",
      "free",
      "lsblk"
    ],
    "answer": "df",
    "explanation": "'df' (disk free) shows file system disk space usage, including total, used, and available space."
  },
  {
    "id": 117,
    "topic": "File Systems",
    "question": "What is the main advantage of extent-based allocation over block lists?",
    "options": [
      "Better security",
      "Reduced metadata overhead for large files",
      "Faster file deletion",
      "Automatic file compression"
    ],
    "answer": "Reduced metadata overhead for large files",
    "explanation": "Instead of listing every block, extents store start block and length, drastically cutting metadata for contiguous files."
  },
  {
    "id": 118,
    "topic": "File Systems",
    "question": "Which of the following is a characteristic of network file systems (e.g., NFS)?",
    "options": [
      "Files are stored only in RAM",
      "File access is transparent over a network",
      "They cannot be mounted locally",
      "They require dedicated hardware"
    ],
    "answer": "File access is transparent over a network",
    "explanation": "NFS allows remote file systems to be mounted and accessed as if they were local, using standard file operations."
  },
  {
    "id": 119,
    "topic": "File Systems",
    "question": "What is the 'sticky bit' used for in modern Unix systems?",
    "options": [
      "To prevent file execution",
      "To restrict file deletion in directories to the file owner",
      "To compress file contents",
      "To encrypt file metadata"
    ],
    "answer": "To restrict file deletion in directories to the file owner",
    "explanation": "When set on a directory (e.g., /tmp), only the file owner, directory owner, or root can delete files within it."
  },
  {
    "id": 120,
    "topic": "File Systems",
    "question": "Which system call creates a symbolic link?",
    "options": [
      "link()",
      "symlink()",
      "mklink()",
      "softlink()"
    ],
    "answer": "symlink()",
    "explanation": "symlink() creates a symbolic link pointing to a specified target path."
  },
  {
    "id": 121,
    "topic": "CPU Scheduling",
    "question": "Which scheduling algorithm minimizes average waiting time if burst times are known?",
    "options": [
      "FCFS",
      "SJF",
      "Round Robin",
      "Priority Scheduling"
    ],
    "answer": "SJF",
    "explanation": "Shortest Job First (SJF) is optimal for minimizing average waiting time when CPU burst durations are known in advance."
  },
  {
    "id": 122,
    "topic": "CPU Scheduling",
    "question": "What is the primary goal of CPU scheduling?",
    "options": [
      "To maximize disk I/O",
      "To keep the CPU as busy as possible",
      "To minimize memory usage",
      "To reduce network latency"
    ],
    "answer": "To keep the CPU as busy as possible",
    "explanation": "CPU scheduling aims to maximize utilization by ensuring the CPU always has a process to execute."
  },
  {
    "id": 123,
    "topic": "CPU Scheduling",
    "question": "Which of the following is a non-preemptive scheduling algorithm?",
    "options": [
      "Round Robin",
      "SJF (non-preemptive version)",
      "Multilevel Feedback Queue",
      "SRTF"
    ],
    "answer": "SJF (non-preemptive version)",
    "explanation": "Non-preemptive SJF runs a process to completion once started, even if a shorter job arrives later."
  },
  {
    "id": 124,
    "topic": "CPU Scheduling",
    "question": "What is turnaround time?",
    "options": [
      "Time from submission to completion of a process",
      "Time a process spends waiting in the ready queue",
      "Time taken for a context switch",
      "Time between I/O requests"
    ],
    "answer": "Time from submission to completion of a process",
    "explanation": "Turnaround time = completion time - arrival time; it includes waiting, execution, and I/O time."
  },
  {
    "id": 125,
    "topic": "CPU Scheduling",
    "question": "Which scheduling algorithm uses multiple queues with different priorities?",
    "options": [
      "FCFS",
      "Multilevel Queue Scheduling",
      "SJF",
      "Lottery Scheduling"
    ],
    "answer": "Multilevel Queue Scheduling",
    "explanation": "Processes are permanently assigned to queues (e.g., system, interactive, batch), each with its own scheduling algorithm."
  },
  {
    "id": 126,
    "topic": "CPU Scheduling",
    "question": "What is response time in scheduling?",
    "options": [
      "Time from process submission to first response",
      "Total CPU time used by a process",
      "Time between process creation and termination",
      "Time spent in I/O operations"
    ],
    "answer": "Time from process submission to first response",
    "explanation": "Response time is critical for interactive systems; it measures how quickly a system starts reacting to a request."
  },
  {
    "id": 127,
    "topic": "CPU Scheduling",
    "question": "Which algorithm is prone to the convoy effect?",
    "options": [
      "Round Robin",
      "SJF",
      "FCFS",
      "Priority Scheduling"
    ],
    "answer": "FCFS",
    "explanation": "In FCFS, a long CPU-bound process can hold the CPU, forcing shorter I/O-bound processes to wait, reducing overall efficiency."
  },
  {
    "id": 128,
    "topic": "CPU Scheduling",
    "question": "What is the main disadvantage of pure priority scheduling?",
    "options": [
      "It causes high context switch overhead",
      "It can lead to starvation of low-priority processes",
      "It requires knowing burst times in advance",
      "It is not suitable for multiprocessor systems"
    ],
    "answer": "It can lead to starvation of low-priority processes",
    "explanation": "Without aging, low-priority processes may never get CPU time if higher-priority processes keep arriving."
  },
  {
    "id": 129,
    "topic": "CPU Scheduling",
    "question": "Which of the following is true about the Round Robin algorithm?",
    "options": [
      "It is non-preemptive",
      "It gives each process a fixed time slice",
      "It always minimizes waiting time",
      "It cannot be used with I/O-bound processes"
    ],
    "answer": "It gives each process a fixed time slice",
    "explanation": "Round Robin is preemptive and uses time quanta to ensure fairness among ready processes."
  },
  {
    "id": 130,
    "topic": "CPU Scheduling",
    "question": "What is the purpose of the ready queue?",
    "options": [
      "To hold processes waiting for I/O",
      "To hold processes ready to execute and waiting for CPU",
      "To store terminated processes",
      "To manage disk requests"
    ],
    "answer": "To hold processes ready to execute and waiting for CPU",
    "explanation": "The ready queue contains all processes in main memory that are prepared to run, awaiting CPU allocation."
  },
  {
    "id": 131,
    "topic": "CPU Scheduling",
    "question": "Which scheduling algorithm is used in Linux’s Completely Fair Scheduler (CFS)?",
    "options": [
      "Round Robin",
      "Multilevel Feedback Queue",
      "Red-Black Tree based fair-share scheduling",
      "FCFS"
    ],
    "answer": "Red-Black Tree based fair-share scheduling",
    "explanation": "CFS uses a red-black tree to track process virtual runtimes and schedules the process with the smallest runtime next."
  },
  {
    "id": 132,
    "topic": "CPU Scheduling",
    "question": "What is dispatch latency?",
    "options": [
      "Time to switch from user to kernel mode",
      "Time taken by the dispatcher to stop one process and start another",
      "Time a process waits for I/O",
      "Time between process creation and first execution"
    ],
    "answer": "Time taken by the dispatcher to stop one process and start another",
    "explanation": "Dispatch latency affects real-time system responsiveness; lower latency means faster context switches."
  },
  {
    "id": 133,
    "topic": "CPU Scheduling",
    "question": "Which of the following best describes SRTF?",
    "options": [
      "Non-preemptive version of SJF",
      "Preemptive version of SJF",
      "A type of priority scheduling",
      "A disk scheduling algorithm"
    ],
    "answer": "Preemptive version of SJF",
    "explanation": "Shortest Remaining Time First (SRTF) preempts the current process if a new one arrives with a shorter remaining burst time."
  },
  {
    "id": 134,
    "topic": "CPU Scheduling",
    "question": "What is the main criterion for CPU scheduling in batch systems?",
    "options": [
      "Response time",
      "Throughput and turnaround time",
      "Fairness",
      "Deadline compliance"
    ],
    "answer": "Throughput and turnaround time",
    "explanation": "Batch systems prioritize maximizing jobs completed per unit time and minimizing total completion time."
  },
  {
    "id": 135,
    "topic": "CPU Scheduling",
    "question": "Which scheduling algorithm assigns CPU based on externally defined priorities?",
    "options": [
      "FCFS",
      "SJF",
      "Priority Scheduling",
      "Round Robin"
    ],
    "answer": "Priority Scheduling",
    "explanation": "Each process is assigned a priority (static or dynamic), and the CPU is allocated to the highest-priority process."
  },
  {
    "id": 136,
    "topic": "CPU Scheduling",
    "question": "What is throughput in CPU scheduling?",
    "options": [
      "Number of processes completed per unit time",
      "Average time a process spends in the ready queue",
      "CPU utilization percentage",
      "Memory bandwidth usage"
    ],
    "answer": "Number of processes completed per unit time",
    "explanation": "High throughput is desirable in batch systems where many jobs need to be processed efficiently."
  },
  {
    "id": 137,
    "topic": "CPU Scheduling",
    "question": "Which of the following is a solution to starvation in priority scheduling?",
    "options": [
      "Decreasing time quantum",
      "Aging",
      "Increasing context switch frequency",
      "Using FCFS for all processes"
    ],
    "answer": "Aging",
    "explanation": "Aging gradually increases the priority of waiting processes, ensuring they eventually get CPU time."
  },
  {
    "id": 138,
    "topic": "CPU Scheduling",
    "question": "What is the main advantage of multilevel feedback queue scheduling?",
    "options": [
      "It requires no parameters",
      "It automatically adjusts process priorities based on behavior",
      "It guarantees zero waiting time",
      "It eliminates the need for context switching"
    ],
    "answer": "It automatically adjusts process priorities based on behavior",
    "explanation": "Processes that use too much CPU are demoted to lower queues; I/O-bound processes stay in higher-priority queues."
  },
  {
    "id": 139,
    "topic": "CPU Scheduling",
    "question": "Which of the following is true about real-time scheduling?",
    "options": [
      "It prioritizes throughput over deadlines",
      "It guarantees response within specified time constraints",
      "It uses only Round Robin algorithm",
      "It is identical to batch scheduling"
    ],
    "answer": "It guarantees response within specified time constraints",
    "explanation": "Real-time systems (hard or soft) must meet timing deadlines for correctness or quality of service."
  },
  {
    "id": 140,
    "topic": "CPU Scheduling",
    "question": "What is the role of the scheduler in an OS?",
    "options": [
      "To allocate memory to processes",
      "To select which process runs next on the CPU",
      "To manage file system permissions",
      "To handle network packets"
    ],
    "answer": "To select which process runs next on the CPU",
    "explanation": "The scheduler (short-term) chooses from the ready queue based on the scheduling algorithm in use."
  },
  {
    "id": 141,
    "topic": "CPU Scheduling",
    "question": "Which algorithm is most suitable for time-sharing systems?",
    "options": [
      "FCFS",
      "SJF",
      "Round Robin",
      "Non-preemptive Priority"
    ],
    "answer": "Round Robin",
    "explanation": "Round Robin provides good response time and fairness, essential for interactive time-sharing environments."
  },
  {
    "id": 142,
    "topic": "CPU Scheduling",
    "question": "What happens if the time quantum in Round Robin is too large?",
    "options": [
      "It behaves like SJF",
      "It behaves like FCFS",
      "Context switch overhead increases",
      "Starvation occurs"
    ],
    "answer": "It behaves like FCFS",
    "explanation": "A very large time quantum means processes rarely get preempted, effectively turning RR into FCFS."
  },
  {
    "id": 143,
    "topic": "CPU Scheduling",
    "question": "Which of the following is a key performance metric for interactive systems?",
    "options": [
      "Throughput",
      "Turnaround time",
      "Response time",
      "CPU utilization"
    ],
    "answer": "Response time",
    "explanation": "Users care how quickly the system responds to inputs, making response time critical for interactivity."
  },
  {
    "id": 144,
    "topic": "CPU Scheduling",
    "question": "What is the main disadvantage of SJF?",
    "options": [
      "It causes high context switch overhead",
      "It requires accurate prediction of future CPU bursts",
      "It cannot handle I/O-bound processes",
      "It is not preemptive"
    ],
    "answer": "It requires accurate prediction of future CPU bursts",
    "explanation": "Since burst times are rarely known in advance, SJF often relies on estimates (e.g., exponential averaging)."
  },
  {
    "id": 145,
    "topic": "CPU Scheduling",
    "question": "Which scheduling algorithm is used in Windows NT-based systems for threads?",
    "options": [
      "Pure Round Robin",
      "Multilevel Feedback Queue",
      "FCFS",
      "Lottery Scheduling"
    ],
    "answer": "Multilevel Feedback Queue",
    "explanation": "Windows uses a 32-level priority scheme with dynamic priority adjustment based on thread behavior."
  },
  {
    "id": 146,
    "topic": "CPU Scheduling",
    "question": "What is the purpose of the 'nice' command in Unix?",
    "options": [
      "To terminate a process politely",
      "To adjust the priority of a process",
      "To list running processes",
      "To compress process memory"
    ],
    "answer": "To adjust the priority of a process",
    "explanation": "nice changes the scheduling priority (niceness value), affecting how much CPU time a process receives."
  },
  {
    "id": 147,
    "topic": "CPU Scheduling",
    "question": "Which of the following is true about I/O-bound processes?",
    "options": [
      "They spend more time doing computations",
      "They frequently request I/O and have short CPU bursts",
      "They should be given low priority",
      "They do not interact with the scheduler"
    ],
    "answer": "They frequently request I/O and have short CPU bursts",
    "explanation": "I/O-bound processes benefit from high priority in interactive systems to improve responsiveness."
  },
  {
    "id": 148,
    "topic": "CPU Scheduling",
    "question": "What is the main goal of real-time scheduling algorithms like EDF?",
    "options": [
      "Maximize throughput",
      "Meet all deadlines by executing the earliest deadline first",
      "Minimize memory usage",
      "Ensure fairness among all processes"
    ],
    "answer": "Meet all deadlines by executing the earliest deadline first",
    "explanation": "Earliest Deadline First (EDF) is optimal for uniprocessor real-time systems under certain conditions."
  },
  {
    "id": 149,
    "topic": "CPU Scheduling",
    "question": "Which of the following is NOT a CPU scheduling algorithm?",
    "options": [
      "FCFS",
      "SJF",
      "SCAN",
      "Round Robin"
    ],
    "answer": "SCAN",
    "explanation": "SCAN is a disk scheduling algorithm, not a CPU scheduling method."
  },
  {
    "id": 150,
    "topic": "CPU Scheduling",
    "question": "What is the effect of a very small time quantum in Round Robin?",
    "options": [
      "Improved CPU utilization",
      "Reduced context switch overhead",
      "Increased context switch overhead",
      "Better throughput"
    ],
    "answer": "Increased context switch overhead",
    "explanation": "Frequent preemptions lead to more context switches, consuming CPU cycles that could be used for actual work."
  },
  {
    "id": 151,
    "topic": "CPU Scheduling",
    "question": "Which scheduler is also known as the CPU scheduler?",
    "options": [
      "Long-term scheduler",
      "Short-term scheduler",
      "Medium-term scheduler",
      "I/O scheduler"
    ],
    "answer": "Short-term scheduler",
    "explanation": "The short-term scheduler selects which ready process gets the CPU next and is invoked frequently."
  },
  {
    "id": 152,
    "topic": "CPU Scheduling",
    "question": "What is the main difference between preemptive and non-preemptive scheduling?",
    "options": [
      "Preemptive uses priorities; non-preemptive does not",
      "Preemptive can interrupt a running process; non-preemptive cannot",
      "Non-preemptive is only used in real-time systems",
      "Preemptive requires more memory"
    ],
    "answer": "Preemptive can interrupt a running process; non-preemptive cannot",
    "explanation": "Preemption allows the scheduler to forcibly take the CPU from a process, improving responsiveness."
  },
  {
    "id": 153,
    "topic": "CPU Scheduling",
    "question": "Which of the following scheduling algorithms can lead to Belady’s anomaly?",
    "options": [
      "Optimal",
      "LRU",
      "FIFO",
      "Clock"
    ],
    "answer": "FIFO",
    "explanation": "Belady’s anomaly occurs when increasing page frames leads to more page faults, possible in FIFO but not in stack algorithms like LRU."
  },
  {
    "id": 154,
    "topic": "CPU Scheduling",
    "question": "What is the primary scheduling concern in real-time operating systems?",
    "options": [
      "Fairness",
      "Deadline compliance",
      "Memory efficiency",
      "Disk throughput"
    ],
    "answer": "Deadline compliance",
    "explanation": "Correctness in real-time systems depends on meeting timing constraints, not just functional correctness."
  },
  {
    "id": 155,
    "topic": "CPU Scheduling",
    "question": "Which of the following is a characteristic of the Completely Fair Scheduler (CFS)?",
    "options": [
      "It uses fixed time slices for all processes",
      "It aims to give each process an equal share of CPU time",
      "It is non-preemptive",
      "It only supports real-time processes"
    ],
    "answer": "It aims to give each process an equal share of CPU time",
    "explanation": "CFS uses virtual runtime to ensure fairness, approximating ideal multitasking."
  },
  {
    "id": 156,
    "topic": "CPU Scheduling",
    "question": "What is the role of the medium-term scheduler?",
    "options": [
      "To select processes from disk to memory",
      "To swap processes in and out of memory",
      "To assign CPU to ready processes",
      "To manage I/O requests"
    ],
    "answer": "To swap processes in and out of memory",
    "explanation": "The medium-term scheduler handles swapping, reducing the degree of multiprogramming when memory is low."
  },
  {
    "id": 157,
    "topic": "CPU Scheduling",
    "question": "Which of the following is true about CPU-bound processes?",
    "options": [
      "They frequently perform I/O operations",
      "They spend most of their time in CPU computation",
      "They should always run at high priority",
      "They have short CPU bursts"
    ],
    "answer": "They spend most of their time in CPU computation",
    "explanation": "CPU-bound processes use long CPU bursts and are common in scientific computing or rendering tasks."
  },
  {
    "id": 158,
    "topic": "CPU Scheduling",
    "question": "What is the main advantage of multilevel queue scheduling over simple priority scheduling?",
    "options": [
      "It prevents starvation by design",
      "It allows different scheduling algorithms per queue",
      "It requires no context switching",
      "It uses less memory"
    ],
    "answer": "It allows different scheduling algorithms per queue",
    "explanation": "For example, the system queue might use RR, while the batch queue uses FCFS, optimizing for different process types."
  },
  {
    "id": 159,
    "topic": "CPU Scheduling",
    "question": "Which scheduling algorithm is optimal for minimizing average waiting time but is not practical?",
    "options": [
      "FCFS",
      "SJF",
      "Optimal (clairvoyant)",
      "Round Robin"
    ],
    "answer": "Optimal (clairvoyant)",
    "explanation": "The optimal algorithm requires knowing all future burst times, which is impossible in real systems."
  },
  {
    "id": 160,
    "topic": "CPU Scheduling",
    "question": "What is the main purpose of scheduling queues?",
    "options": [
      "To store file data",
      "To organize processes based on their state and scheduling needs",
      "To manage network connections",
      "To cache disk blocks"
    ],
    "answer": "To organize processes based on their state and scheduling needs",
    "explanation": "Queues like ready, wait, and device queues help the OS manage process flow efficiently."
  },
  {
    "id": 161,
    "topic": "Deadlocks",
    "question": "Which of the following is NOT one of the four necessary conditions for deadlock?",
    "options": [
      "Mutual exclusion",
      "Hold and wait",
      "No preemption",
      "Circular wait",
      "Resource starvation"
    ],
    "answer": "Resource starvation",
    "explanation": "The four Coffman conditions are mutual exclusion, hold and wait, no preemption, and circular wait. Starvation is different."
  },
  {
    "id": 162,
    "topic": "Deadlocks",
    "question": "What is the Banker’s algorithm used for?",
    "options": [
      "To detect deadlocks",
      "To prevent deadlocks by ensuring safe resource allocation",
      "To recover from deadlocks",
      "To allocate memory efficiently"
    ],
    "answer": "To prevent deadlocks by ensuring safe resource allocation",
    "explanation": "The Banker’s algorithm simulates resource allocation to ensure the system remains in a safe state."
  },
  {
    "id": 163,
    "topic": "Deadlocks",
    "question": "Which deadlock handling strategy involves ignoring the problem altogether?",
    "options": [
      "Deadlock prevention",
      "Deadlock avoidance",
      "Deadlock detection and recovery",
      "Ostrich algorithm"
    ],
    "answer": "Ostrich algorithm",
    "explanation": "The 'ostrich algorithm' assumes deadlocks are rare and ignores them, used in systems like Unix/Linux."
  },
  {
    "id": 164,
    "topic": "Deadlocks",
    "question": "How can the 'hold and wait' condition be prevented?",
    "options": [
      "By allowing preemption of resources",
      "By requiring processes to request all resources at once",
      "By breaking circular waits",
      "By using timeouts"
    ],
    "answer": "By requiring processes to request all resources at once",
    "explanation": "If a process must request all needed resources before execution, it won’t hold some while waiting for others."
  },
  {
    "id": 165,
    "topic": "Deadlocks",
    "question": "What is a resource allocation graph used for?",
    "options": [
      "To visualize file system structure",
      "To detect deadlocks in systems with single-instance resources",
      "To schedule CPU time",
      "To manage memory pages"
    ],
    "answer": "To detect deadlocks in systems with single-instance resources",
    "explanation": "A cycle in a resource allocation graph implies a deadlock when each resource type has only one instance."
  },
  {
    "id": 166,
    "topic": "Deadlocks",
    "question": "Which of the following is a method of deadlock recovery?",
    "options": [
      "Preventing mutual exclusion",
      "Terminating one or more processes involved in the deadlock",
      "Increasing CPU speed",
      "Disabling interrupts"
    ],
    "answer": "Terminating one or more processes involved in the deadlock",
    "explanation": "Recovery may involve aborting processes or preempting resources to break the deadlock cycle."
  },
  {
    "id": 167,
    "topic": "Deadlocks",
    "question": "What does it mean for a system state to be 'safe' in deadlock avoidance?",
    "options": [
      "No deadlocks have occurred yet",
      "There exists a sequence of process completions where all can finish",
      "All resources are idle",
      "The system is in single-user mode"
    ],
    "answer": "There exists a sequence of process completions where all can finish",
    "explanation": "A safe state guarantees that no matter what resource requests are made, deadlock can be avoided."
  },
  {
    "id": 168,
    "topic": "Deadlocks",
    "question": "Which condition can be violated by allowing resource preemption?",
    "options": [
      "Mutual exclusion",
      "Hold and wait",
      "No preemption",
      "Circular wait"
    ],
    "answer": "No preemption",
    "explanation": "If resources can be forcibly taken from a process, the 'no preemption' condition is violated, helping prevent deadlock."
  },
  {
    "id": 169,
    "topic": "Deadlocks",
    "question": "What is the main disadvantage of deadlock prevention?",
    "options": [
      "It increases memory usage",
      "It can lead to low resource utilization",
      "It requires more CPU cores",
      "It slows down I/O operations"
    ],
    "answer": "It can lead to low resource utilization",
    "explanation": "Prevention strategies (e.g., requesting all resources upfront) may cause processes to hold unused resources, wasting capacity."
  },
  {
    "id": 170,
    "topic": "Deadlocks",
    "question": "In a system with multiple instances per resource type, how is deadlock detection performed?",
    "options": [
      "Using a resource allocation graph",
      "Using wait-for graphs",
      "Using the Banker’s algorithm",
      "Using a safety algorithm"
    ],
    "answer": "Using wait-for graphs",
    "explanation": "Wait-for graphs (processes only) are used for detection in multi-instance systems, where cycles indicate potential deadlock."
  },
  {
    "id": 171,
    "topic": "Deadlocks",
    "question": "Which of the following best describes deadlock avoidance?",
    "options": [
      "Ensuring that at least one Coffman condition never holds",
      "Dynamically examining resource requests to ensure safety",
      "Ignoring deadlocks as rare events",
      "Killing processes periodically"
    ],
    "answer": "Dynamically examining resource requests to ensure safety",
    "explanation": "Avoidance (e.g., Banker’s algorithm) grants requests only if the resulting state is safe."
  },
  {
    "id": 172,
    "topic": "Deadlocks",
    "question": "What is a disadvantage of the Banker’s algorithm?",
    "options": [
      "It requires fixed number of processes",
      "It assumes maximum resource needs are known in advance",
      "It only works with single-instance resources",
      "It cannot handle I/O devices"
    ],
    "answer": "It assumes maximum resource needs are known in advance",
    "explanation": "Processes must declare their maximum resource requirements upfront, which is often impractical."
  },
  {
    "id": 173,
    "topic": "Deadlocks",
    "question": "How can circular wait be prevented?",
    "options": [
      "By imposing a total ordering on resource types",
      "By allowing preemption",
      "By requiring all-or-nothing allocation",
      "By using semaphores"
    ],
    "answer": "By imposing a total ordering on resource types",
    "explanation": "If processes request resources in increasing order of type number, circular waits cannot form."
  },
  {
    "id": 174,
    "topic": "Deadlocks",
    "question": "Which of the following is true about deadlock detection?",
    "options": [
      "It prevents deadlocks from occurring",
      "It allows deadlocks to occur and then detects them",
      "It is less expensive than prevention",
      "It guarantees system safety"
    ],
    "answer": "It allows deadlocks to occur and then detects them",
    "explanation": "Detection algorithms run periodically to find deadlocks, after which recovery is initiated."
  },
  {
    "id": 175,
    "topic": "Deadlocks",
    "question": "What is the main idea behind the 'wait-die' deadlock prevention scheme?",
    "options": [
      "Older processes wait; younger ones die (abort)",
      "Younger processes wait; older ones die",
      "All processes wait indefinitely",
      "Processes roll back to previous states"
    ],
    "answer": "Older processes wait; younger ones die (abort)",
    "explanation": "In wait-die, if an older process requests a resource held by a younger one, it waits; if a younger requests from an older, it aborts."
  },
  {
    "id": 176,
    "topic": "Deadlocks",
    "question": "Which of the following is a non-resource deadlock example?",
    "options": [
      "Two processes waiting for a printer",
      "Two threads waiting for each other’s locks in opposite order",
      "A process waiting for disk I/O",
      "A process blocked on a full buffer"
    ],
    "answer": "Two threads waiting for each other’s locks in opposite order",
    "explanation": "This is a classic synchronization deadlock, not involving physical resources like printers or disks."
  },
  {
    "id": 177,
    "topic": "Deadlocks",
    "question": "What is the 'wound-wait' scheme?",
    "options": [
      "Older processes wait; younger are aborted",
      "Younger processes wait; older preempt (wound) younger",
      "All processes are rolled back",
      "Resources are deallocated randomly"
    ],
    "answer": "Younger processes wait; older preempt (wound) younger",
    "explanation": "In wound-wait, an older process requesting a resource from a younger one forces the younger to abort and restart later."
  },
  {
    "id": 178,
    "topic": "Deadlocks",
    "question": "Which of the following is required for the Banker’s algorithm to work?",
    "options": [
      "Resources must be preemptable",
      "Number of processes must be fixed",
      "Each process must declare max resource needs in advance",
      "All resources must be identical"
    ],
    "answer": "Each process must declare max resource needs in advance",
    "explanation": "This allows the algorithm to simulate future allocations and determine if a state is safe."
  },
  {
    "id": 179,
    "topic": "Deadlocks",
    "question": "What is a disadvantage of deadlock detection and recovery?",
    "options": [
      "It prevents all deadlocks",
      "It can incur significant overhead and process loss",
      "It requires no system resources",
      "It guarantees high throughput"
    ],
    "answer": "It can incur significant overhead and process loss",
    "explanation": "Detecting deadlocks and recovering (e.g., by killing processes) wastes work and may frustrate users."
  },
  {
    "id": 180,
    "topic": "Deadlocks",
    "question": "Which graph is used for deadlock detection in multi-instance resource systems?",
    "options": [
      "Resource allocation graph",
      "Wait-for graph",
      "Process dependency graph",
      "State transition graph"
    ],
    "answer": "Wait-for graph",
    "explanation": "The wait-for graph has edges from Pi to Pj if Pi is waiting for a resource held by Pj; a cycle indicates deadlock."
  },
  {
    "id": 181,
    "topic": "Deadlocks",
    "question": "What is the main difference between deadlock prevention and avoidance?",
    "options": [
      "Prevention is dynamic; avoidance is static",
      "Prevention ensures at least one Coffman condition never holds; avoidance dynamically avoids unsafe states",
      "Avoidance ignores deadlocks; prevention handles them",
      "Prevention uses graphs; avoidance uses matrices"
    ],
    "answer": "Prevention ensures at least one Coffman condition never holds; avoidance dynamically avoids unsafe states",
    "explanation": "Prevention is more restrictive but simpler; avoidance is flexible but requires more information and computation."
  },
  {
    "id": 182,
    "topic": "Deadlocks",
    "question": "Which of the following systems is most likely to use the ostrich algorithm?",
    "options": [
      "Air traffic control system",
      "Nuclear reactor controller",
      "Desktop operating system like Linux",
      "Real-time missile guidance"
    ],
    "answer": "Desktop operating system like Linux",
    "explanation": "General-purpose OSes often assume deadlocks are rare and rely on application-level design to avoid them."
  },
  {
    "id": 183,
    "topic": "Deadlocks",
    "question": "What is a safe sequence in the context of the Banker’s algorithm?",
    "options": [
      "A sequence where all processes can finish without deadlock",
      "A sequence that minimizes CPU usage",
      "A sequence that uses the least memory",
      "A random ordering of processes"
    ],
    "answer": "A sequence where all processes can finish without deadlock",
    "explanation": "If such a sequence exists, the system state is safe, and resource requests can be granted."
  },
  {
    "id": 184,
    "topic": "Deadlocks",
    "question": "Which condition is violated if resources can be forcibly taken from a process?",
    "options": [
      "Mutual exclusion",
      "Hold and wait",
      "No preemption",
      "Circular wait"
    ],
    "answer": "No preemption",
    "explanation": "Allowing preemption breaks the 'no preemption' condition, aiding in deadlock prevention."
  },
  {
    "id": 185,
    "topic": "Deadlocks",
    "question": "What is the primary cost of using the Banker’s algorithm?",
    "options": [
      "Increased disk I/O",
      "Runtime overhead of safety checks for every request",
      "Higher memory consumption for processes",
      "Slower context switching"
    ],
    "answer": "Runtime overhead of safety checks for every request",
    "explanation": "Each resource request triggers a safety algorithm simulation, which can be expensive in large systems."
  },
  {
    "id": 186,
    "topic": "Deadlocks",
    "question": "In a resource allocation graph, what does a cycle imply?",
    "options": [
      "Always a deadlock",
      "Deadlock only if all resources have single instances",
      "No deadlock possible",
      "High system throughput"
    ],
    "answer": "Deadlock only if all resources have single instances",
    "explanation": "With multiple instances, a cycle is necessary but not sufficient for deadlock."
  },
  {
    "id": 187,
    "topic": "Deadlocks",
    "question": "Which of the following is a recovery strategy from deadlock?",
    "options": [
      "Preventing mutual exclusion",
      "Rolling back processes to safe states",
      "Increasing time quantum",
      "Disabling virtual memory"
    ],
    "answer": "Rolling back processes to safe states",
    "explanation": "If checkpoints are maintained, processes can be restarted from earlier states to break deadlock."
  },
  {
    "id": 188,
    "topic": "Deadlocks",
    "question": "What is the main assumption of the ostrich algorithm?",
    "options": [
      "Deadlocks are frequent and must be handled",
      "Deadlocks are so rare that it’s not worth handling them",
      "All systems are deadlock-free by design",
      "Hardware prevents deadlocks automatically"
    ],
    "answer": "Deadlocks are so rare that it’s not worth handling them",
    "explanation": "This pragmatic approach is used when the cost of prevention/avoidance outweighs the risk."
  },
  {
    "id": 189,
    "topic": "Deadlocks",
    "question": "Which of the following is true about the 'hold and wait' condition?",
    "options": [
      "A process holds no resources while waiting",
      "A process holds at least one resource while waiting for others",
      "Resources are allocated in a circular chain",
      "Resources cannot be shared"
    ],
    "answer": "A process holds at least one resource while waiting for others",
    "explanation": "This condition, combined with others, enables deadlock formation."
  },
  {
    "id": 190,
    "topic": "Deadlocks",
    "question": "What is the role of the 'available' vector in the Banker’s algorithm?",
    "options": [
      "Tracks total system resources",
      "Tracks resources currently allocated to processes",
      "Tracks resources not currently allocated",
      "Tracks maximum resource needs per process"
    ],
    "answer": "Tracks resources not currently allocated",
    "explanation": "The 'available' vector is used in the safety algorithm to simulate resource allocation."
  },
  {
    "id": 191,
    "topic": "Deadlocks",
    "question": "Which of the following best prevents circular wait?",
    "options": [
      "Allowing preemption",
      "Requiring all resources upfront",
      "Imposing a linear ordering on resource types",
      "Using timeouts"
    ],
    "answer": "Imposing a linear ordering on resource types",
    "explanation": "If all processes request resources in the same order, circular dependencies cannot occur."
  },
  {
    "id": 192,
    "topic": "Deadlocks",
    "question": "What is a disadvantage of requiring processes to request all resources at once?",
    "options": [
      "It increases context switches",
      "It reduces CPU utilization",
      "It leads to low resource utilization and possible starvation",
      "It requires more disk space"
    ],
    "answer": "It leads to low resource utilization and possible starvation",
    "explanation": "Processes may hold resources they don’t immediately need, blocking others and wasting capacity."
  },
  {
    "id": 193,
    "topic": "Deadlocks",
    "question": "Which of the following is a characteristic of deadlock avoidance?",
    "options": [
      "It is less restrictive than prevention",
      "It guarantees 100% CPU utilization",
      "It works without knowing resource needs",
      "It eliminates the need for scheduling"
    ],
    "answer": "It is less restrictive than prevention",
    "explanation": "Avoidance allows more concurrency by dynamically checking safety rather than imposing static rules."
  },
  {
    "id": 194,
    "topic": "Deadlocks",
    "question": "In the Banker’s algorithm, what does the 'need' matrix represent?",
    "options": [
      "Total system resources",
      "Resources currently held by each process",
      "Maximum demand minus currently allocated resources",
      "Available resources"
    ],
    "answer": "Maximum demand minus currently allocated resources",
    "explanation": "Need[i][j] = Max[i][j] - Allocation[i][j], indicating remaining resource requirements for process i."
  },
  {
    "id": 195,
    "topic": "Deadlocks",
    "question": "What is the main challenge in implementing deadlock detection in large systems?",
    "options": [
      "High memory usage",
      "Frequent false positives",
      "Significant computational overhead",
      "Incompatibility with virtual memory"
    ],
    "answer": "Significant computational overhead",
    "explanation": "Running detection algorithms frequently can consume substantial CPU time, especially with many processes/resources."
  },
  {
    "id": 196,
    "topic": "Deadlocks",
    "question": "Which of the following is true about mutual exclusion?",
    "options": [
      "It can always be avoided",
      "It is required for non-sharable resources like printers",
      "It prevents all deadlocks",
      "It is not a Coffman condition"
    ],
    "answer": "It is required for non-sharable resources like printers",
    "explanation": "Mutual exclusion is necessary for resources that cannot be shared simultaneously; it’s one of the four deadlock conditions."
  },
  {
    "id": 197,
    "topic": "Deadlocks",
    "question": "What is the primary purpose of a wait-for graph?",
    "options": [
      "To allocate memory to waiting processes",
      "To detect deadlocks among processes",
      "To schedule I/O operations",
      "To visualize CPU usage"
    ],
    "answer": "To detect deadlocks among processes",
    "explanation": "A cycle in the wait-for graph indicates that a set of processes are deadlocked."
  },
  {
    "id": 198,
    "topic": "Deadlocks",
    "question": "Which of the following is a practical way to handle deadlock in databases?",
    "options": [
      "Ignore it completely",
      "Use timeouts and transaction rollback",
      "Prevent all resource sharing",
      "Allocate infinite resources"
    ],
    "answer": "Use timeouts and transaction rollback",
    "explanation": "Databases often detect potential deadlocks via wait-for graphs and abort one transaction to resolve it."
  },
  {
    "id": 199,
    "topic": "Deadlocks",
    "question": "What is the main idea behind deadlock prevention?",
    "options": [
      "Allow deadlocks but recover quickly",
      "Ensure that at least one necessary condition for deadlock never occurs",
      "Guess when deadlocks will happen",
      "Use more memory to avoid resource contention"
    ],
    "answer": "Ensure that at least one necessary condition for deadlock never occurs",
    "explanation": "By negating one of the four Coffman conditions, deadlock becomes impossible."
  },
  {
    "id": 200,
    "topic": "Deadlocks",
    "question": "Which of the following is NOT a valid method to break a deadlock?",
    "options": [
      "Process termination",
      "Resource preemption",
      "Increasing CPU clock speed",
      "Rollback to a checkpoint"
    ],
    "answer": "Increasing CPU clock speed",
    "explanation": "CPU speed has no effect on resource allocation cycles that cause deadlock."
  },
  {
    "id": 201,
    "topic": "Device Management",
    "question": "What is the primary role of a device driver?",
    "options": [
      "To manage user accounts",
      "To provide a software interface to control hardware devices",
      "To allocate CPU time to processes",
      "To compress disk data"
    ],
    "answer": "To provide a software interface to control hardware devices",
    "explanation": "Device drivers translate OS I/O requests into device-specific commands, abstracting hardware complexity."
  },
  {
    "id": 202,
    "topic": "Device Management",
    "question": "Which of the following is a characteristic of block devices?",
    "options": [
      "Data is accessed sequentially only",
      "Data is transferred in fixed-size blocks",
      "They cannot be mounted as file systems",
      "They include keyboards and mice"
    ],
    "answer": "Data is transferred in fixed-size blocks",
    "explanation": "Block devices (e.g., hard drives) allow random access and transfer data in blocks, typically 512B–4KB."
  },
  {
    "id": 203,
    "topic": "Device Management",
    "question": "What is the purpose of the I/O scheduler in Linux?",
    "options": [
      "To allocate memory to device drivers",
      "To reorder I/O requests to optimize disk head movement",
      "To manage CPU scheduling for I/O-bound processes",
      "To encrypt data before writing to disk"
    ],
    "answer": "To reorder I/O requests to optimize disk head movement",
    "explanation": "I/O schedulers (e.g., CFQ, Deadline, NOOP) reduce seek time and improve throughput on mechanical disks."
  },
  {
    "id": 204,
    "topic": "Device Management",
    "question": "Which of the following is a character device?",
    "options": [
      "Hard disk",
      "USB flash drive",
      "Keyboard",
      "CD-ROM"
    ],
    "answer": "Keyboard",
    "explanation": "Character devices (e.g., keyboards, serial ports) transfer data as a stream of bytes, not in blocks."
  },
  {
    "id": 205,
    "topic": "Device Management",
    "question": "What is polling in device management?",
    "options": [
      "Sending data to a device periodically",
      "The CPU repeatedly checking a device’s status register",
      "Waiting for a device interrupt",
      "Compressing device data"
    ],
    "answer": "The CPU repeatedly checking a device’s status register",
    "explanation": "Polling wastes CPU cycles but is simple; interrupts are more efficient for sporadic I/O."
  },
  {
    "id": 206,
    "topic": "Device Management",
    "question": "What is the main advantage of using interrupts over polling?",
    "options": [
      "Simpler hardware design",
      "Lower CPU overhead",
      "Faster data transfer rates",
      "No need for device drivers"
    ],
    "answer": "Lower CPU overhead",
    "explanation": "Interrupts allow the CPU to perform other tasks until the device signals completion, improving efficiency."
  },
  {
    "id": 207,
    "topic": "Device Management",
    "question": "Which component handles interrupt requests in the OS?",
    "options": [
      "File system",
      "Interrupt handler",
      "Memory manager",
      "Scheduler"
    ],
    "answer": "Interrupt handler",
    "explanation": "The interrupt handler (or ISR) is a kernel routine that responds to hardware interrupts, often waking waiting processes."
  },
  {
    "id": 208,
    "topic": "Device Management",
    "question": "What is DMA (Direct Memory Access)?",
    "options": [
      "A method for encrypting memory",
      "A technique allowing devices to transfer data directly to/from memory without CPU involvement",
      "A type of virtual memory",
      "A CPU scheduling algorithm"
    ],
    "answer": "A technique allowing devices to transfer data directly to/from memory without CPU involvement",
    "explanation": "DMA offloads data transfer from the CPU, freeing it for other tasks and improving I/O performance."
  },
  {
    "id": 209,
    "topic": "Device Management",
    "question": "Which of the following is true about device independence?",
    "options": [
      "Programs must know the exact hardware model",
      "Programs access devices through generic interfaces (e.g., file operations)",
      "Each device requires a unique programming language",
      "Device drivers are not needed"
    ],
    "answer": "Programs access devices through generic interfaces (e.g., file operations)",
    "explanation": "Device independence allows applications to use standard I/O calls (read/write) regardless of underlying hardware."
  },
  {
    "id": 210,
    "topic": "Device Management",
    "question": "What is a spooling system used for?",
    "options": [
      "Compressing print jobs",
      "Buffering I/O for slow devices like printers",
      "Encrypting disk data",
      "Managing CPU caches"
    ],
    "answer": "Buffering I/O for slow devices like printers",
    "explanation": "Spooling (Simultaneous Peripheral Operations On-Line) queues jobs (e.g., print requests) to keep the CPU busy."
  },
  {
    "id": 211,
    "topic": "Device Management",
    "question": "Which of the following best describes a device controller?",
    "options": [
      "A user application that controls devices",
      "A hardware component that interfaces between the device and the OS",
      "A type of CPU register",
      "A network protocol"
    ],
    "answer": "A hardware component that interfaces between the device and the OS",
    "explanation": "Device controllers manage low-level device operations and communicate with the CPU via registers and interrupts."
  },
  {
    "id": 212,
    "topic": "Device Management",
    "question": "What is the purpose of the 'major number' in Unix device files?",
    "options": [
      "Identifies the specific device instance",
      "Identifies the device driver associated with the device",
      "Indicates disk block size",
      "Specifies file permissions"
    ],
    "answer": "Identifies the device driver associated with the device",
    "explanation": "The major number routes I/O requests to the correct driver; the minor number identifies the specific device."
  },
  {
    "id": 213,
    "topic": "Device Management",
    "question": "Which I/O technique allows overlapping of CPU and I/O operations?",
    "options": [
      "Programmed I/O",
      "Interrupt-driven I/O",
      "DMA",
      "Both B and C"
    ],
    "answer": "Both B and C",
    "explanation": "Interrupt-driven I/O and DMA allow the CPU to work on other tasks while I/O is in progress."
  },
  {
    "id": 214,
    "topic": "Device Management",
    "question": "What is the main disadvantage of programmed I/O (polling)?",
    "options": [
      "High hardware cost",
      "Wastes CPU cycles",
      "Requires special CPU instructions",
      "Cannot handle multiple devices"
    ],
    "answer": "Wastes CPU cycles",
    "explanation": "The CPU is busy waiting and cannot perform useful work during I/O operations."
  },
  {
    "id": 215,
    "topic": "Device Management",
    "question": "Which of the following is a goal of I/O scheduling?",
    "options": [
      "Maximize CPU utilization",
      "Minimize disk seek time and improve throughput",
      "Reduce memory fragmentation",
      "Prevent deadlocks"
    ],
    "answer": "Minimize disk seek time and improve throughput",
    "explanation": "I/O schedulers reorder requests to reduce mechanical movement in HDDs, though less relevant for SSDs."
  },
  {
    "id": 216,
    "topic": "Device Management",
    "question": "What is the role of the buffer cache in device management?",
    "options": [
      "To store user passwords",
      "To cache disk blocks in memory for faster access",
      "To compress network packets",
      "To manage process priorities"
    ],
    "answer": "To cache disk blocks in memory for faster access",
    "explanation": "The buffer cache reduces disk I/O by keeping frequently accessed blocks in RAM."
  },
  {
    "id": 217,
    "topic": "Device Management",
    "question": "Which of the following is true about hot-pluggable devices?",
    "options": [
      "They can be added or removed without rebooting",
      "They require system shutdown for installation",
      "They cannot use DMA",
      "They are only supported on mainframes"
    ],
    "answer": "They can be added or removed without rebooting",
    "explanation": "USB, PCIe, and Thunderbolt devices support hot-plugging, managed by the OS and drivers."
  },
  {
    "id": 218,
    "topic": "Device Management",
    "question": "What is the purpose of the 'minor number' in Unix device files?",
    "options": [
      "Identifies the device driver",
      "Identifies a specific device instance managed by the driver",
      "Specifies block size",
      "Indicates file system type"
    ],
    "answer": "Identifies a specific device instance managed by the driver",
    "explanation": "For example, multiple disk partitions share the same major number (driver) but have unique minor numbers."
  },
  {
    "id": 219,
    "topic": "Device Management",
    "question": "Which of the following is an example of a human interface device (HID)?",
    "options": [
      "Hard drive",
      "Network card",
      "Mouse",
      "GPU"
    ],
    "answer": "Mouse",
    "explanation": "HIDs include keyboards, mice, joysticks—devices that interact directly with users."
  },
  {
    "id": 220,
    "topic": "Device Management",
    "question": "What is the main purpose of the device file system (devfs) in Unix-like systems?",
    "options": [
      "To store user documents",
      "To provide a file system interface to hardware devices",
      "To manage disk partitions",
      "To log system errors"
    ],
    "answer": "To provide a file system interface to hardware devices",
    "explanation": "Device files (e.g., /dev/sda, /dev/tty) allow programs to interact with hardware using standard file I/O."
  },
  {
    "id": 221,
    "topic": "Device Management",
    "question": "Which of the following is a disadvantage of using interrupts for every I/O completion?",
    "options": [
      "High latency for large transfers",
      "Excessive CPU overhead for high-speed devices",
      "Incompatibility with DMA",
      "Requires more memory"
    ],
    "answer": "Excessive CPU overhead for high-speed devices",
    "explanation": "High-frequency interrupts (e.g., from 10GbE NICs) can overwhelm the CPU; solutions include interrupt coalescing."
  },
  {
    "id": 222,
    "topic": "Device Management",
    "question": "What is interrupt coalescing?",
    "options": [
      "Combining multiple devices into one interrupt line",
      "Delaying interrupts to batch multiple I/O completions",
      "Disabling interrupts during critical sections",
      "Encrypting interrupt data"
    ],
    "answer": "Delaying interrupts to batch multiple I/O completions",
    "explanation": "Coalescing reduces interrupt frequency at the cost of slight latency increase, improving CPU efficiency."
  },
  {
    "id": 223,
    "topic": "Device Management",
    "question": "Which of the following best describes memory-mapped I/O?",
    "options": [
      "I/O devices are accessed via special CPU instructions",
      "I/O device registers are mapped into the CPU’s address space",
      "All I/O is redirected to RAM",
      "I/O is performed only during system idle time"
    ],
    "answer": "I/O device registers are mapped into the CPU’s address space",
    "explanation": "Memory-mapped I/O allows reading/writing device registers using standard load/store instructions."
  },
  {
    "id": 224,
    "topic": "Device Management",
    "question": "What is the role of the I/O request queue?",
    "options": [
      "To store file metadata",
      "To hold pending I/O operations for a device",
      "To manage process priorities",
      "To cache network packets"
    ],
    "answer": "To hold pending I/O operations for a device",
    "explanation": "The I/O scheduler reorders requests in this queue to optimize performance."
  },
  {
    "id": 225,
    "topic": "Device Management",
    "question": "Which of the following is true about SSDs compared to HDDs in I/O scheduling?",
    "options": [
      "SSDs benefit more from seek optimization",
      "SSDs have no seek time, so complex I/O schedulers are less useful",
      "SSDs cannot use DMA",
      "SSDs require more interrupts"
    ],
    "answer": "SSDs have no seek time, so complex I/O schedulers are less useful",
    "explanation": "Since SSDs have no moving parts, schedulers like NOOP (which does minimal reordering) are often preferred."
  },
  {
    "id": 226,
    "topic": "Device Management",
    "question": "What is the purpose of the 'sync' system call in relation to devices?",
    "options": [
      "To synchronize clocks across devices",
      "To flush cached data to persistent storage",
      "To pair Bluetooth devices",
      "To reset device drivers"
    ],
    "answer": "To flush cached data to persistent storage",
    "explanation": "sync() ensures that modified data in the buffer cache is written to disk, ensuring durability."
  },
  {
    "id": 227,
    "topic": "Device Management",
    "question": "Which of the following is a characteristic of a virtual device?",
    "options": [
      "It has no physical hardware",
      "It is always slower than physical devices",
      "It cannot be accessed via device files",
      "It requires dedicated CPU cores"
    ],
    "answer": "It has no physical hardware",
    "explanation": "Examples include /dev/null, /dev/zero, and loopback devices—they exist only in software."
  },
  {
    "id": 228,
    "topic": "Device Management",
    "question": "What is the main function of the udev system in Linux?",
    "options": [
      "To manage user accounts",
      "To dynamically create and manage device nodes in /dev",
      "To schedule CPU tasks",
      "To compress disk images"
    ],
    "answer": "To dynamically create and manage device nodes in /dev",
    "explanation": "udev responds to kernel device events (e.g., USB plug-in) and creates/removes device files accordingly."
  },
  {
    "id": 229,
    "topic": "Device Management",
    "question": "Which of the following is true about port-mapped I/O?",
    "options": [
      "It uses the same address space as memory",
      "It uses special IN/OUT instructions to access device ports",
      "It is faster than memory-mapped I/O",
      "It is not supported on x86"
    ],
    "answer": "It uses special IN/OUT instructions to access device ports",
    "explanation": "Port-mapped I/O uses a separate address space and instructions (e.g., x86 IN/OUT), unlike memory-mapped I/O."
  },
  {
    "id": 230,
    "topic": "Device Management",
    "question": "What is the primary benefit of using double buffering in I/O?",
    "options": [
      "Reduces memory usage",
      "Allows CPU to process one buffer while I/O fills another",
      "Encrypts data during transfer",
      "Prevents deadlocks"
    ],
    "answer": "Allows CPU to process one buffer while I/O fills another",
    "explanation": "Double buffering enables continuous I/O by alternating between two buffers, improving throughput."
  },
  {
    "id": 231,
    "topic": "Device Management",
    "question": "Which of the following is a role of the device-independent I/O layer in the OS?",
    "options": [
      "To generate device-specific commands",
      "To provide uniform interfaces (e.g., open, read, write) across devices",
      "To manage CPU registers",
      "To allocate disk blocks"
    ],
    "answer": "To provide uniform interfaces (e.g., open, read, write) across devices",
    "explanation": "This layer abstracts hardware differences, allowing applications to use consistent system calls."
  },
  {
    "id": 232,
    "topic": "Device Management",
    "question": "What is a disadvantage of using DMA?",
    "options": [
      "Higher CPU usage",
      "Increased complexity and potential security risks (e.g., DMA attacks)",
      "Slower data transfer",
      "Incompatibility with virtual memory"
    ],
    "answer": "Increased complexity and potential security risks (e.g., DMA attacks)",
    "explanation": "DMA-capable devices can access physical memory directly, posing risks if compromised (mitigated by IOMMU)."
  },
  {
    "id": 233,
    "topic": "Device Management",
    "question": "Which of the following best describes an IOMMU?",
    "options": [
      "A CPU cache for I/O operations",
      "A memory management unit for I/O devices that enables DMA with virtual addresses",
      "A type of disk scheduler",
      "A network protocol for device discovery"
    ],
    "answer": "A memory management unit for I/O devices that enables DMA with virtual addresses",
    "explanation": "IOMMU translates device virtual addresses to physical addresses, enhancing security and enabling features like VFIO."
  },
  {
    "id": 234,
    "topic": "Device Management",
    "question": "What is the purpose of the 'ioctl' system call?",
    "options": [
      "To perform device-specific operations not covered by standard I/O calls",
      "To allocate memory for devices",
      "To terminate device drivers",
      "To list connected devices"
    ],
    "answer": "To perform device-specific operations not covered by standard I/O calls",
    "explanation": "ioctl() allows control operations like ejecting a CD, configuring network interfaces, or adjusting volume."
  },
  {
    "id": 235,
    "topic": "Device Management",
    "question": "Which of the following is true about the 'dd' command in Unix?",
    "options": [
      "It deletes device drivers",
      "It is used for low-level copying and conversion of data, often with devices",
      "It disables DMA",
      "It lists device files"
    ],
    "answer": "It is used for low-level copying and conversion of data, often with devices",
    "explanation": "dd can clone disks (e.g., 'dd if=/dev/sda of=image.img'), create bootable USBs, or wipe drives."
  },
  {
    "id": 236,
    "topic": "Device Management",
    "question": "What is the main purpose of the 'lspci' command?",
    "options": [
      "To list PCI devices and their drivers",
      "To format PCI disks",
      "To allocate IRQs to devices",
      "To monitor CPU temperature"
    ],
    "answer": "To list PCI devices and their drivers",
    "explanation": "lspci shows connected PCI/PCIe devices, useful for debugging hardware and driver issues."
  },
  {
    "id": 237,
    "topic": "Device Management",
    "question": "Which of the following is a characteristic of asynchronous I/O?",
    "options": [
      "The process blocks until I/O completes",
      "The process continues execution and is notified later when I/O is done",
      "It cannot be used with DMA",
      "It is slower than synchronous I/O"
    ],
    "answer": "The process continues execution and is notified later when I/O is done",
    "explanation": "Asynchronous I/O improves concurrency by allowing the process to perform other work during I/O."
  },
  {
    "id": 238,
    "topic": "Device Management",
    "question": "What is the role of the 'sysfs' file system in Linux?",
    "options": [
      "To store user files",
      "To export kernel device and driver information to user space",
      "To cache disk blocks",
      "To manage process IDs"
    ],
    "answer": "To export kernel device and driver information to user space",
    "explanation": "sysfs (mounted at /sys) provides a hierarchical view of devices, drivers, and kernel objects."
  },
  {
    "id": 239,
    "topic": "Device Management",
    "question": "Which of the following is true about plug and play (PnP)?",
    "options": [
      "It requires manual driver installation for every device",
      "It automatically detects and configures hardware devices",
      "It is only used in embedded systems",
      "It disables interrupts"
    ],
    "answer": "It automatically detects and configures hardware devices",
    "explanation": "PnP allows the OS to recognize new hardware and load appropriate drivers without user intervention."
  },
  {
    "id": 240,
    "topic": "Device Management",
    "question": "What is the primary function of a terminal device driver?",
    "options": [
      "To manage disk partitions",
      "To handle input/output for text-based interfaces (e.g., TTY)",
      "To control GPU rendering",
      "To schedule network packets"
    ],
    "answer": "To handle input/output for text-based interfaces (e.g., TTY)",
    "explanation": "TTY drivers manage serial ports, virtual consoles, and pseudo-terminals (ptys) for shells and SSH."
  },
  {
    "id": 241,
    "topic": "Security & Protection",
    "question": "What is the principle of least privilege?",
    "options": [
      "Granting users maximum access for convenience",
      "Granting processes only the privileges they need to perform their tasks",
      "Allowing all system calls by default",
      "Encrypting all user data automatically"
    ],
    "answer": "Granting processes only the privileges they need to perform their tasks",
    "explanation": "Least privilege minimizes the damage from compromised or buggy programs by restricting their access."
  },
  {
    "id": 242,
    "topic": "Security & Protection",
    "question": "Which of the following is a mechanism for memory protection in modern OSes?",
    "options": [
      "Base and limit registers",
      "File compression",
      "Round Robin scheduling",
      "Symbolic links"
    ],
    "answer": "Base and limit registers",
    "explanation": "These hardware registers define the logical address range a process can access, preventing unauthorized memory access."
  },
  {
    "id": 243,
    "topic": "Security & Protection",
    "question": "What is a capability in the context of OS security?",
    "options": [
      "A user password",
      "A token that grants permission to perform specific operations on an object",
      "A type of virus",
      "A CPU instruction set"
    ],
    "answer": "A token that grants permission to perform specific operations on an object",
    "explanation": "Capabilities are unforgeable references that combine an object identifier with access rights."
  },
  {
    "id": 244,
    "topic": "Security & Protection",
    "question": "Which of the following best describes a sandbox?",
    "options": [
      "A physical security device",
      "An isolated environment for running untrusted code",
      "A type of file system",
      "A memory allocation strategy"
    ],
    "answer": "An isolated environment for running untrusted code",
    "explanation": "Sandboxing restricts a program’s access to system resources, limiting potential damage from malicious or faulty code."
  },
  {
    "id": 245,
    "topic": "Security & Protection",
    "question": "What is the main purpose of access control lists (ACLs)?",
    "options": [
      "To list all system users",
      "To define fine-grained permissions for users and groups on objects",
      "To encrypt file contents",
      "To manage CPU scheduling"
    ],
    "answer": "To define fine-grained permissions for users and groups on objects",
    "explanation": "ACLs extend traditional Unix permissions by allowing per-user/group access rules on files and directories."
  },
  {
    "id": 246,
    "topic": "Security & Protection",
    "question": "Which of the following is a common method to prevent buffer overflow attacks?",
    "options": [
      "Using larger buffers",
      "Disabling interrupts",
      "Stack canaries and address space layout randomization (ASLR)",
      "Increasing time quantum"
    ],
    "answer": "Stack canaries and address space layout randomization (ASLR)",
    "explanation": "Stack canaries detect overwrites, while ASLR randomizes memory layout to make exploitation harder."
  },
  {
    "id": 247,
    "topic": "Security & Protection",
    "question": "What is mandatory access control (MAC)?",
    "options": [
      "Access decisions based on user identity only",
      "Access controlled by system-wide policies, not user discretion",
      "A method for compressing files",
      "A type of CPU scheduling"
    ],
    "answer": "Access controlled by system-wide policies, not user discretion",
    "explanation": "MAC (e.g., SELinux, AppArmor) enforces security policies defined by administrators, overriding user settings."
  },
  {
    "id": 248,
    "topic": "Security & Protection",
    "question": "Which of the following is true about discretionary access control (DAC)?",
    "options": [
      "Policies are set by the system administrator only",
      "Object owners can grant access to other users",
      "It is more restrictive than MAC",
      "It cannot be used with file systems"
    ],
    "answer": "Object owners can grant access to other users",
    "explanation": "DAC (e.g., Unix file permissions) allows owners to decide who can access their files."
  },
  {
    "id": 249,
    "topic": "Security & Protection",
    "question": "What is the role of the Trusted Computing Base (TCB)?",
    "options": [
      "To manage user accounts",
      "To include all hardware, firmware, and software critical to system security",
      "To schedule I/O operations",
      "To compress memory pages"
    ],
    "answer": "To include all hardware, firmware, and software critical to system security",
    "explanation": "The TCB must be trusted because any flaw in it can compromise the entire system’s security."
  },
  {
    "id": 250,
    "topic": "Security & Protection",
    "question": "Which of the following is a goal of OS protection mechanisms?",
    "options": [
      "To maximize CPU utilization",
      "To prevent unauthorized access and ensure resource isolation",
      "To reduce disk fragmentation",
      "To speed up context switches"
    ],
    "answer": "To prevent unauthorized access and ensure resource isolation",
    "explanation": "Protection ensures that processes cannot interfere with each other or the OS kernel."
  },
  {
    "id": 251,
    "topic": "Security & Protection",
    "question": "What is a rootkit?",
    "options": [
      "A legitimate system utility",
      "Malware that gains privileged access and hides its presence",
      "A type of firewall",
      "A memory management technique"
    ],
    "answer": "Malware that gains privileged access and hides its presence",
    "explanation": "Rootkits often modify OS components (e.g., system calls) to conceal files, processes, or network connections."
  },
  {
    "id": 252,
    "topic": "Security & Protection",
    "question": "Which of the following best describes privilege escalation?",
    "options": [
      "Reducing a user’s permissions",
      "Exploiting a vulnerability to gain higher access rights",
      "Encrypting user data",
      "Compressing system logs"
    ],
    "answer": "Exploiting a vulnerability to gain higher access rights",
    "explanation": "Privilege escalation attacks aim to move from user to admin or root level, often via software bugs."
  },
  {
    "id": 253,
    "topic": "Security & Protection",
    "question": "What is the purpose of a firewall in an OS?",
    "options": [
      "To cool the CPU",
      "To monitor and control incoming/outgoing network traffic",
      "To manage disk partitions",
      "To schedule processes"
    ],
    "answer": "To monitor and control incoming/outgoing network traffic",
    "explanation": "Firewalls enforce security policies at the network level, blocking unauthorized connections."
  },
  {
    "id": 254,
    "topic": "Security & Protection",
    "question": "Which of the following is a characteristic of a secure OS design?",
    "options": [
      "Complexity for enhanced features",
      "Minimal TCB and defense in depth",
      "Default full access for all users",
      "No logging of security events"
    ],
    "answer": "Minimal TCB and defense in depth",
    "explanation": "A small TCB is easier to verify; defense in depth uses multiple layers (e.g., firewalls, MAC, ASLR) for security."
  },
  {
    "id": 255,
    "topic": "Security & Protection",
    "question": "What is role-based access control (RBAC)?",
    "options": [
      "Access based on user passwords",
      "Access granted based on job functions or roles",
      "A method for encrypting roles",
      "A CPU scheduling policy"
    ],
    "answer": "Access granted based on job functions or roles",
    "explanation": "RBAC simplifies administration by assigning permissions to roles, then assigning users to roles."
  },
  {
    "id": 256,
    "topic": "Security & Protection",
    "question": "Which of the following is true about ASLR?",
    "options": [
      "It makes buffer overflows impossible",
      "It randomizes the memory layout of processes to hinder exploitation",
      "It disables all system calls",
      "It is only used in Windows"
    ],
    "answer": "It randomizes the memory layout of processes to hinder exploitation",
    "explanation": "ASLR makes it harder for attackers to predict addresses of code or data, raising the bar for exploits."
  },
  {
    "id": 257,
    "topic": "Security & Protection",
    "question": "What is the main purpose of a system call interface in security?",
    "options": [
      "To provide a controlled entry point into the kernel",
      "To speed up user programs",
      "To manage file compression",
      "To allocate disk blocks"
    ],
    "answer": "To provide a controlled entry point into the kernel",
    "explanation": "System calls are the only way user programs can request kernel services, allowing the OS to enforce security checks."
  },
  {
    "id": 258,
    "topic": "Security & Protection",
    "question": "Which of the following is a common cause of security vulnerabilities in OSes?",
    "options": [
      "Too much logging",
      "Buffer overflows and race conditions",
      "Excessive use of virtual memory",
      "Round Robin scheduling"
    ],
    "answer": "Buffer overflows and race conditions",
    "explanation": "These programming errors can allow attackers to execute arbitrary code or bypass security checks."
  },
  {
    "id": 259,
    "topic": "Security & Protection",
    "question": "What is the principle of fail-safe defaults?",
    "options": [
      "Grant access unless explicitly denied",
      "Deny access unless explicitly granted",
      "Allow all system calls by default",
      "Encrypt all data on failure"
    ],
    "answer": "Deny access unless explicitly granted",
    "explanation": "Fail-safe defaults ensure that security is maintained even if configuration is incomplete or errors occur."
  },
  {
    "id": 260,
    "topic": "Security & Protection",
    "question": "Which of the following best describes a zero-day vulnerability?",
    "options": [
      "A bug that occurs only on system startup",
      "A vulnerability unknown to the vendor, with no patch available",
      "A flaw in the zero page of memory",
      "A type of denial-of-service attack"
    ],
    "answer": "A vulnerability unknown to the vendor, with no patch available",
    "explanation": "Zero-day exploits target unknown flaws, making them especially dangerous until a fix is developed."
  },
  {
    "id": 261,
    "topic": "Security & Protection",
    "question": "What is the purpose of a secure boot mechanism?",
    "options": [
      "To speed up system startup",
      "To ensure only trusted software runs during the boot process",
      "To compress the kernel image",
      "To allocate more RAM at boot"
    ],
    "answer": "To ensure only trusted software runs during the boot process",
    "explanation": "Secure boot uses cryptographic signatures to verify the bootloader and OS kernel, preventing malware injection."
  },
  {
    "id": 262,
    "topic": "Security & Protection",
    "question": "Which of the following is true about encryption in OS security?",
    "options": [
      "It replaces the need for access control",
      "It protects data at rest and in transit but not during processing",
      "It slows down all system calls",
      "It is only used for network traffic"
    ],
    "answer": "It protects data at rest and in transit but not during processing",
    "explanation": "Data must be decrypted to be used, so memory and CPU protections are still needed for runtime security."
  },
  {
    "id": 263,
    "topic": "Security & Protection",
    "question": "What is a side-channel attack?",
    "options": [
      "An attack that exploits physical characteristics like timing or power consumption",
      "A network-based denial-of-service",
      "A type of phishing scam",
      "A buffer overflow variant"
    ],
    "answer": "An attack that exploits physical characteristics like timing or power consumption",
    "explanation": "Side-channel attacks infer secrets (e.g., cryptographic keys) from indirect information like cache timing (e.g., Spectre)."
  },
  {
    "id": 264,
    "topic": "Security & Protection",
    "question": "Which of the following is a function of SELinux?",
    "options": [
      "To manage user desktop themes",
      "To enforce mandatory access control policies",
      "To schedule CPU tasks",
      "To compress file systems"
    ],
    "answer": "To enforce mandatory access control policies",
    "explanation": "SELinux is a Linux security module that implements MAC, restricting processes based on defined policies."
  },
  {
    "id": 265,
    "topic": "Security & Protection",
    "question": "What is the main security risk of running a process as root?",
    "options": [
      "Slower execution",
      "If compromised, the attacker gains full system control",
      "Increased memory usage",
      "Incompatibility with GUI apps"
    ],
    "answer": "If compromised, the attacker gains full system control",
    "explanation": "Root privileges allow unrestricted access to all system resources, making compromise catastrophic."
  },
  {
    "id": 266,
    "topic": "Security & Protection",
    "question": "Which of the following best describes defense in depth?",
    "options": [
      "Using a single strong firewall",
      "Relying only on encryption",
      "Layering multiple security controls to protect assets",
      "Disabling all user accounts"
    ],
    "answer": "Layering multiple security controls to protect assets",
    "explanation": "Defense in depth combines physical, technical, and administrative controls (e.g., firewalls, MAC, ASLR, training)."
  },
  {
    "id": 267,
    "topic": "Security & Protection",
    "question": "What is the purpose of a reference monitor?",
    "options": [
      "To display system metrics",
      "To mediate all access attempts between subjects and objects",
      "To manage CPU temperature",
      "To allocate disk space"
    ],
    "answer": "To mediate all access attempts between subjects and objects",
    "explanation": "A reference monitor is a theoretical model for access control that must be tamperproof, always invoked, and small enough to be verified."
  },
  {
    "id": 268,
    "topic": "Security & Protection",
    "question": "Which of the following is true about user authentication?",
    "options": [
      "It is optional in secure systems",
      "It verifies the identity of a user before granting access",
      "It replaces the need for authorization",
      "It only uses passwords"
    ],
    "answer": "It verifies the identity of a user before granting access",
    "explanation": "Authentication (e.g., passwords, biometrics) confirms identity; authorization determines what the user can do."
  },
  {
    "id": 269,
    "topic": "Security & Protection",
    "question": "What is a common method to mitigate privilege escalation?",
    "options": [
      "Running all processes as root",
      "Using least privilege and patching vulnerabilities",
      "Disabling all system calls",
      "Increasing swap space"
    ],
    "answer": "Using least privilege and patching vulnerabilities",
    "explanation": "Limiting privileges reduces the impact of exploits; patching removes known escalation paths."
  },
  {
    "id": 270,
    "topic": "Security & Protection",
    "question": "Which of the following is a security benefit of virtualization?",
    "options": [
      "Faster CPU execution",
      "Strong isolation between guest VMs",
      "Reduced memory usage",
      "Automatic code optimization"
    ],
    "answer": "Strong isolation between guest VMs",
    "explanation": "Virtual machines are isolated by the hypervisor, limiting the spread of compromise across guests."
  },
  {
    "id": 271,
    "topic": "Security & Protection",
    "question": "What is the main purpose of logging and auditing in OS security?",
    "options": [
      "To increase disk usage",
      "To detect, investigate, and deter security incidents",
      "To speed up file access",
      "To manage user passwords"
    ],
    "answer": "To detect, investigate, and deter security incidents",
    "explanation": "Logs record security-relevant events (e.g., logins, file accesses), enabling forensic analysis and accountability."
  },
  {
    "id": 272,
    "topic": "Security & Protection",
    "question": "Which of the following is true about capabilities vs. ACLs?",
    "options": [
      "Capabilities are associated with objects; ACLs with subjects",
      "Capabilities are associated with subjects; ACLs with objects",
      "Both are identical in function",
      "Neither is used in modern OSes"
    ],
    "answer": "Capabilities are associated with subjects; ACLs with objects",
    "explanation": "A capability is held by a subject (process) and grants access to an object; an ACL is attached to an object and lists allowed subjects."
  },
  {
    "id": 273,
    "topic": "Security & Protection",
    "question": "What is a trojan horse in OS security?",
    "options": [
      "A legitimate system utility",
      "Malware disguised as useful software",
      "A type of firewall rule",
      "A memory management bug"
    ],
    "answer": "Malware disguised as useful software",
    "explanation": "Trojans trick users into installing them, then perform malicious actions (e.g., stealing data, creating backdoors)."
  },
  {
    "id": 274,
    "topic": "Security & Protection",
    "question": "Which of the following is a goal of input validation in security?",
    "options": [
      "To increase user convenience",
      "To prevent injection attacks and buffer overflows",
      "To compress user input",
      "To speed up system calls"
    ],
    "answer": "To prevent injection attacks and buffer overflows",
    "explanation": "Validating and sanitizing input ensures that malformed data cannot exploit system vulnerabilities."
  },
  {
    "id": 275,
    "topic": "Security & Protection",
    "question": "What is the principle of economy of mechanism?",
    "options": [
      "Use complex designs for better security",
      "Security mechanisms should be as simple and small as possible",
      "Encrypt all mechanisms",
      "Use only open-source mechanisms"
    ],
    "answer": "Security mechanisms should be as simple and small as possible",
    "explanation": "Simpler designs are easier to test, verify, and maintain, reducing the likelihood of hidden flaws."
  },
  {
    "id": 276,
    "topic": "Security & Protection",
    "question": "Which of the following best describes a backdoor?",
    "options": [
      "A legitimate remote administration tool",
      "A hidden method to bypass normal authentication",
      "A type of firewall",
      "A disk partitioning scheme"
    ],
    "answer": "A hidden method to bypass normal authentication",
    "explanation": "Backdoors may be intentionally placed by developers or inserted by attackers to maintain access."
  },
  {
    "id": 277,
    "topic": "Security & Protection",
    "question": "What is the main security advantage of address space layout randomization (ASLR)?",
    "options": [
      "It prevents all malware",
      "It makes it harder for attackers to predict memory addresses",
      "It encrypts the entire address space",
      "It disables buffer overflows"
    ],
    "answer": "It makes it harder for attackers to predict memory addresses",
    "explanation": "By randomizing stack, heap, and library locations, ASLR increases the difficulty of successful exploitation."
  },
  {
    "id": 278,
    "topic": "Security & Protection",
    "question": "Which of the following is true about secure multi-level systems?",
    "options": [
      "All users have the same access level",
      "They enforce strict separation based on security classifications (e.g., Top Secret)",
      "They are only used in gaming",
      "They disable all networking"
    ],
    "answer": "They enforce strict separation based on security classifications (e.g., Top Secret)",
    "explanation": "Multi-level security (e.g., Bell-LaPadula model) prevents information flow from high to low clearance levels."
  },
  {
    "id": 279,
    "topic": "Security & Protection",
    "question": "What is the purpose of a security policy?",
    "options": [
      "To define what resources exist",
      "To specify how security mechanisms should enforce desired behavior",
      "To list all system calls",
      "To manage CPU scheduling"
    ],
    "answer": "To specify how security mechanisms should enforce desired behavior",
    "explanation": "A security policy is a high-level statement of goals (e.g., 'users cannot read files they don’t own'), implemented by mechanisms."
  },
  {
    "id": 280,
    "topic": "Security & Protection",
    "question": "Which of the following is a common OS hardening technique?",
    "options": [
      "Installing all available software",
      "Disabling unnecessary services and ports",
      "Running all processes as root",
      "Using default passwords"
    ],
    "answer": "Disabling unnecessary services and ports",
    "explanation": "Hardening reduces the attack surface by removing or securing unused components."
  },
  {
    "id": 281,
    "topic": "System Calls",
    "question": "What is the primary purpose of system calls?",
    "options": [
      "To allow user programs to request services from the OS kernel",
      "To compile source code",
      "To manage user desktop environments",
      "To allocate disk blocks directly"
    ],
    "answer": "To allow user programs to request services from the OS kernel",
    "explanation": "System calls are the interface between user space and kernel space, enabling controlled access to hardware and OS services."
  },
  {
    "id": 282,
    "topic": "System Calls",
    "question": "Which of the following is a common method for invoking a system call on x86-64 Linux?",
    "options": [
      "Using the 'int 0x80' instruction",
      "Using the 'syscall' instruction",
      "Calling a library function directly",
      "Writing to a special file"
    ],
    "answer": "Using the 'syscall' instruction",
    "explanation": "Modern x86-64 Linux uses the 'syscall' instruction for faster entry into the kernel, replacing the older 'int 0x80'."
  },
  {
    "id": 283,
    "topic": "System Calls",
    "question": "What happens when a system call is executed?",
    "options": [
      "The program terminates immediately",
      "The CPU switches from user mode to kernel mode",
      "The file system is reformatted",
      "Memory is deallocated"
    ],
    "answer": "The CPU switches from user mode to kernel mode",
    "explanation": "This mode switch ensures that privileged kernel code handles the request securely and safely."
  },
  {
    "id": 284,
    "topic": "System Calls",
    "question": "Which system call is used to create a new process in Unix-like systems?",
    "options": [
      "exec()",
      "fork()",
      "spawn()",
      "create()"
    ],
    "answer": "fork()",
    "explanation": "fork() creates a child process that is a copy of the parent; exec() is typically called afterward to load a new program."
  },
  {
    "id": 285,
    "topic": "System Calls",
    "question": "What is the role of the system call table in the kernel?",
    "options": [
      "To store user passwords",
      "To map system call numbers to kernel function pointers",
      "To manage disk partitions",
      "To cache file data"
    ],
    "answer": "To map system call numbers to kernel function pointers",
    "explanation": "When a system call is invoked, the kernel uses the system call number as an index into this table to find the handler."
  },
  {
    "id": 286,
    "topic": "System Calls",
    "question": "Which of the following is NOT a standard system call category?",
    "options": [
      "Process control",
      "File manipulation",
      "Device manipulation",
      "Web browsing"
    ],
    "answer": "Web browsing",
    "explanation": "Web browsing is a user application function, not a kernel-provided system call category."
  },
  {
    "id": 287,
    "topic": "System Calls",
    "question": "What does the 'open' system call return on success?",
    "options": [
      "The file content",
      "A file descriptor (integer)",
      "The file size",
      "The inode number"
    ],
    "answer": "A file descriptor (integer)",
    "explanation": "The file descriptor is an index into the process’s open file table, used in subsequent read/write calls."
  },
  {
    "id": 288,
    "topic": "System Calls",
    "question": "Which system call is used to terminate the calling process?",
    "options": [
      "halt()",
      "stop()",
      "exit()",
      "quit()"
    ],
    "answer": "exit()",
    "explanation": "exit() performs cleanup (e.g., flushing buffers) and returns a status code to the parent process."
  },
  {
    "id": 289,
    "topic": "System Calls",
    "question": "What is the purpose of the 'brk' system call?",
    "options": [
      "To break a file into pieces",
      "To change the location of the program break (end of heap)",
      "To terminate a child process",
      "To flush the CPU cache"
    ],
    "answer": "To change the location of the program break (end of heap)",
    "explanation": "brk() adjusts the heap size by moving the program break pointer, used internally by malloc()."
  },
  {
    "id": 290,
    "topic": "System Calls",
    "question": "Which system call is used to wait for a child process to change state?",
    "options": [
      "join()",
      "wait()",
      "pause()",
      "yield()"
    ],
    "answer": "wait()",
    "explanation": "wait() suspends the parent until a child terminates, allowing it to collect the child’s exit status."
  },
  {
    "id": 291,
    "topic": "System Calls",
    "question": "What is the main difference between 'execve' and 'fork'?",
    "options": [
      "execve creates a new process; fork replaces the current process image",
      "fork creates a new process; execve replaces the current process image",
      "Both create new processes",
      "Both replace the current process image"
    ],
    "answer": "fork creates a new process; execve replaces the current process image",
    "explanation": "fork() duplicates the calling process; execve() loads a new program into the current process’s memory space."
  },
  {
    "id": 292,
    "topic": "System Calls",
    "question": "Which system call is used to send a signal to a process?",
    "options": [
      "signal()",
      "kill()",
      "raise()",
      "abort()"
    ],
    "answer": "kill()",
    "explanation": "kill() sends a specified signal (e.g., SIGTERM) to a process identified by its PID."
  },
  {
    "id": 293,
    "topic": "System Calls",
    "question": "What does the 'mmap' system call do?",
    "options": [
      "Monitors memory usage",
      "Maps files or devices into the process’s virtual address space",
      "Measures memory bandwidth",
      "Moves memory between processes"
    ],
    "answer": "Maps files or devices into the process’s virtual address space",
    "explanation": "mmap() enables file I/O via memory access and is used for shared memory and efficient large-file handling."
  },
  {
    "id": 294,
    "topic": "System Calls",
    "question": "Which system call changes the current working directory?",
    "options": [
      "cd()",
      "chdir()",
      "setdir()",
      "movedir()"
    ],
    "answer": "chdir()",
    "explanation": "chdir() updates the process’s current working directory, affecting relative path resolution."
  },
  {
    "id": 295,
    "topic": "System Calls",
    "question": "What is the purpose of the 'pipe' system call?",
    "options": [
      "To create a named pipe in the file system",
      "To create an anonymous pipe for interprocess communication",
      "To compress data streams",
      "To manage network sockets"
    ],
    "answer": "To create an anonymous pipe for interprocess communication",
    "explanation": "pipe() returns two file descriptors (read and write ends) for unidirectional data flow between related processes."
  },
  {
    "id": 296,
    "topic": "System Calls",
    "question": "Which system call is used to get the process ID of the calling process?",
    "options": [
      "getpid()",
      "getppid()",
      "getuid()",
      "getgid()"
    ],
    "answer": "getpid()",
    "explanation": "getpid() returns the unique process identifier (PID) assigned by the OS."
  },
  {
    "id": 297,
    "topic": "System Calls",
    "question": "What does the 'dup2' system call do?",
    "options": [
      "Duplicates a file descriptor to a specified number",
      "Deletes a file",
      "Duplicates a process",
      "Dumps memory contents"
    ],
    "answer": "Duplicates a file descriptor to a specified number",
    "explanation": "dup2(oldfd, newfd) makes newfd a copy of oldfd, closing newfd first if it was open."
  },
  {
    "id": 298,
    "topic": "System Calls",
    "question": "Which system call is used to create a symbolic link?",
    "options": [
      "link()",
      "symlink()",
      "mklink()",
      "softlink()"
    ],
    "answer": "symlink()",
    "explanation": "symlink() creates a symbolic link pointing to a specified target path."
  },
  {
    "id": 299,
    "topic": "System Calls",
    "question": "What is the role of the 'stat' system call?",
    "options": [
      "To return file content",
      "To return file metadata (size, permissions, timestamps, etc.)",
      "To list directory contents",
      "To allocate disk blocks"
    ],
    "answer": "To return file metadata (size, permissions, timestamps, etc.)",
    "explanation": "stat() retrieves detailed information about a file, including inode number, size, and access/modification times."
  },
  {
    "id": 300,
    "topic": "System Calls",
    "question": "Which system call is used to deallocate memory mapped with mmap()?",
    "options": [
      "free()",
      "munmap()",
      "unmap()",
      "dealloc()"
    ],
    "answer": "munmap()",
    "explanation": "munmap() removes the mapping created by mmap(), freeing the virtual address range."
  },
  {
    "id": 301,
    "topic": "System Calls",
    "question": "What does the 'lseek' system call do?",
    "options": [
      "Searches for a file",
      "Moves the file offset pointer for read/write operations",
      "Locks a file for exclusive access",
      "Lists directory contents"
    ],
    "answer": "Moves the file offset pointer for read/write operations",
    "explanation": "lseek() repositions the read/write pointer within an open file, enabling random access."
  },
  {
    "id": 302,
    "topic": "System Calls",
    "question": "Which system call is used to delete a file?",
    "options": [
      "delete()",
      "remove()",
      "unlink()",
      "erase()"
    ],
    "answer": "unlink()",
    "explanation": "unlink() removes a directory entry and decrements the inode’s link count; the file is deleted when count reaches zero."
  },
  {
    "id": 303,
    "topic": "System Calls",
    "question": "What is the purpose of the 'ioctl' system call?",
    "options": [
      "To perform device-specific operations not covered by standard I/O calls",
      "To allocate memory for devices",
      "To terminate device drivers",
      "To list connected devices"
    ],
    "answer": "To perform device-specific operations not covered by standard I/O calls",
    "explanation": "ioctl() allows control operations like ejecting a CD, configuring network interfaces, or adjusting volume."
  },
  {
    "id": 304,
    "topic": "System Calls",
    "question": "Which system call creates a new directory?",
    "options": [
      "mkdir()",
      "create()",
      "makedir()",
      "newdir()"
    ],
    "answer": "mkdir()",
    "explanation": "mkdir() creates a new empty directory with specified permissions."
  },
  {
    "id": 305,
    "topic": "System Calls",
    "question": "What does the 'getuid' system call return?",
    "options": [
      "Process ID",
      "Parent process ID",
      "Real user ID of the calling process",
      "Group ID"
    ],
    "answer": "Real user ID of the calling process",
    "explanation": "getuid() returns the numeric user identifier of the process owner, used for permission checks."
  },
  {
    "id": 306,
    "topic": "System Calls",
    "question": "Which system call is used to flush file system buffers to disk?",
    "options": [
      "flush()",
      "sync()",
      "fsync()",
      "Both B and C"
    ],
    "answer": "Both B and C",
    "explanation": "sync() flushes all buffers; fsync() flushes buffers for a specific file descriptor."
  },
  {
    "id": 307,
    "topic": "System Calls",
    "question": "What is the main purpose of the 'clone' system call in Linux?",
    "options": [
      "To duplicate a file",
      "To create a new process or thread with fine-grained control over shared resources",
      "To copy memory pages",
      "To compress data"
    ],
    "answer": "To create a new process or thread with fine-grained control over shared resources",
    "explanation": "clone() is a flexible alternative to fork(), allowing shared memory, file descriptors, etc., used to implement threads."
  },
  {
    "id": 308,
    "topic": "System Calls",
    "question": "Which system call changes the ownership of a file?",
    "options": [
      "chown()",
      "chmod()",
      "chgrp()",
      "chuser()"
    ],
    "answer": "chown()",
    "explanation": "chown() changes the user and/or group owner of a file, requiring appropriate privileges."
  },
  {
    "id": 309,
    "topic": "System Calls",
    "question": "What does the 'alarm' system call do?",
    "options": [
      "Sounds a system beep",
      "Schedules a SIGALRM signal to be delivered after a specified number of seconds",
      "Locks the screen",
      "Terminates the process"
    ],
    "answer": "Schedules a SIGALRM signal to be delivered after a specified number of seconds",
    "explanation": "alarm() is used for simple timeouts; the process can catch SIGALRM to handle the event."
  },
  {
    "id": 310,
    "topic": "System Calls",
    "question": "Which system call is used to get the current working directory?",
    "options": [
      "pwd()",
      "getcwd()",
      "cwd()",
      "dir()"
    ],
    "answer": "getcwd()",
    "explanation": "getcwd() (get current working directory) returns the absolute path of the process’s current directory."
  },
  {
    "id": 311,
    "topic": "System Calls",
    "question": "What is the purpose of the 'umask' system call?",
    "options": [
      "To set the default file permissions mask for new files",
      "To unmount a file system",
      "To disable masking of interrupts",
      "To compress memory"
    ],
    "answer": "To set the default file permissions mask for new files",
    "explanation": "umask specifies which permission bits to turn off when creating files or directories."
  },
  {
    "id": 312,
    "topic": "System Calls",
    "question": "Which system call is used to change file permissions?",
    "options": [
      "chown()",
      "chmod()",
      "chperm()",
      "chaccess()"
    ],
    "answer": "chmod()",
    "explanation": "chmod() modifies the read, write, and execute permissions for user, group, and others."
  },
  {
    "id": 313,
    "topic": "System Calls",
    "question": "What does the 'read' system call return on success?",
    "options": [
      "The file descriptor",
      "The number of bytes read",
      "The file content as a string",
      "0 on success, -1 on error"
    ],
    "answer": "The number of bytes read",
    "explanation": "read() returns the number of bytes actually read, which may be less than requested (e.g., at EOF)."
  },
  {
    "id": 314,
    "topic": "System Calls",
    "question": "Which system call is used to create a hard link?",
    "options": [
      "link()",
      "symlink()",
      "hardlink()",
      "mklink()"
    ],
    "answer": "link()",
    "explanation": "link() creates a new directory entry (hard link) pointing to an existing inode."
  },
  {
    "id": 315,
    "topic": "System Calls",
    "question": "What is the main difference between 'write' and 'pwrite' system calls?",
    "options": [
      "pwrite writes to a pipe; write writes to files",
      "pwrite allows specifying an offset without changing the file pointer",
      "write is synchronous; pwrite is asynchronous",
      "There is no difference"
    ],
    "answer": "pwrite allows specifying an offset without changing the file pointer",
    "explanation": "pwrite(fd, buf, count, offset) writes at 'offset' without affecting the file descriptor’s current position."
  },
  {
    "id": 316,
    "topic": "System Calls",
    "question": "Which system call is used to mount a file system?",
    "options": [
      "mount()",
      "attach()",
      "link()",
      "join()"
    ],
    "answer": "mount()",
    "explanation": "mount() attaches a file system (e.g., from a disk partition) to a directory (mount point) in the existing hierarchy."
  },
  {
    "id": 317,
    "topic": "System Calls",
    "question": "What does the 'nanosleep' system call do?",
    "options": [
      "Puts the process to sleep for a specified number of nanoseconds",
      "Measures CPU nanoseconds",
      "Sleeps until a network packet arrives",
      "Compresses sleep data"
    ],
    "answer": "Puts the process to sleep for a specified number of nanoseconds",
    "explanation": "nanosleep() provides high-resolution sleep, with the ability to resume if interrupted by a signal."
  },
  {
    "id": 318,
    "topic": "System Calls",
    "question": "Which system call is used to get the process ID of the parent process?",
    "options": [
      "getpid()",
      "getppid()",
      "getuid()",
      "getgid()"
    ],
    "answer": "getppid()",
    "explanation": "getppid() returns the PID of the process that created the calling process."
  },
  {
    "id": 319,
    "topic": "System Calls",
    "question": "What is the purpose of the 'fcntl' system call?",
    "options": [
      "To control file descriptor properties",
      "To encrypt file contents",
      "To manage CPU frequency",
      "To list network connections"
    ],
    "answer": "To control file descriptor properties",
    "explanation": "fcntl() can duplicate file descriptors, set flags (e.g., O_NONBLOCK), or manage file locks."
  },
  {
    "id": 320,
    "topic": "System Calls",
    "question": "Which system call is used to unmount a file system?",
    "options": [
      "umount()",
      "detach()",
      "unlink()",
      "unjoin()"
    ],
    "answer": "umount()",
    "explanation": "umount() detaches a mounted file system from the directory tree, ensuring all data is flushed first."
  },
  {
    "id": 321,
    "topic": "Virtual Memory",
    "question": "What is the primary benefit of virtual memory?",
    "options": [
      "It increases physical RAM size",
      "It allows programs to use more memory than physically available",
      "It speeds up disk access",
      "It prevents all memory leaks"
    ],
    "answer": "It allows programs to use more memory than physically available",
    "explanation": "Virtual memory uses disk as an extension of RAM, enabling execution of large applications on limited hardware."
  },
  {
    "id": 322,
    "topic": "Virtual Memory",
    "question": "Which of the following is stored in the page table?",
    "options": [
      "File metadata",
      "Mapping between virtual and physical addresses",
      "CPU register values",
      "Process priority levels"
    ],
    "answer": "Mapping between virtual and physical addresses",
    "explanation": "The page table translates virtual page numbers to physical frame numbers for address resolution."
  },
  {
    "id": 323,
    "topic": "Virtual Memory",
    "question": "What causes a page fault?",
    "options": [
      "A hardware failure in RAM",
      "Accessing a virtual page not currently in physical memory",
      "Writing to a read-only file",
      "Exceeding CPU temperature limits"
    ],
    "answer": "Accessing a virtual page not currently in physical memory",
    "explanation": "A page fault triggers the OS to load the required page from disk (e.g., swap space) into RAM."
  },
  {
    "id": 324,
    "topic": "Virtual Memory",
    "question": "Which algorithm replaces the page that has not been used for the longest time?",
    "options": [
      "FIFO",
      "Optimal",
      "LRU",
      "Clock"
    ],
    "answer": "LRU",
    "explanation": "Least Recently Used (LRU) approximates optimal page replacement by evicting the least recently accessed page."
  },
  {
    "id": 325,
    "topic": "Virtual Memory",
    "question": "What is internal fragmentation?",
    "options": [
      "Unused space within allocated memory blocks",
      "Gaps between memory segments",
      "Corrupted memory pages",
      "Memory leaks due to unreleased pointers"
    ],
    "answer": "Unused space within allocated memory blocks",
    "explanation": "Internal fragmentation occurs when allocated memory is larger than requested (e.g., in fixed-size paging)."
  },
  {
    "id": 326,
    "topic": "Virtual Memory",
    "question": "What is the purpose of the Translation Lookaside Buffer (TLB)?",
    "options": [
      "To cache disk blocks",
      "To store recently used virtual-to-physical address translations",
      "To buffer keyboard input",
      "To compress memory pages"
    ],
    "answer": "To store recently used virtual-to-physical address translations",
    "explanation": "The TLB is a hardware cache that speeds up virtual address translation by avoiding page table walks."
  },
  {
    "id": 327,
    "topic": "Virtual Memory",
    "question": "Which memory management technique uses variable-sized partitions?",
    "options": [
      "Paging",
      "Segmentation",
      "Swapping",
      "Caching"
    ],
    "answer": "Segmentation",
    "explanation": "Segmentation divides memory into logical units (e.g., code, data, stack) of varying sizes, unlike fixed-size pages."
  },
  {
    "id": 328,
    "topic": "Virtual Memory",
    "question": "What is thrashing?",
    "options": [
      "Excessive disk I/O due to constant page swapping",
      "CPU overheating from high load",
      "Memory corruption from buffer overflows",
      "Network congestion from too many processes"
    ],
    "answer": "Excessive disk I/O due to constant page swapping",
    "explanation": "Thrashing occurs when the system spends more time swapping pages than executing useful work, often due to insufficient RAM."
  },
  {
    "id": 329,
    "topic": "Virtual Memory",
    "question": "Which of the following is a disadvantage of segmentation?",
    "options": [
      "It increases memory access speed",
      "It eliminates external fragmentation",
      "It can lead to external fragmentation",
      "It requires more TLB entries"
    ],
    "answer": "It can lead to external fragmentation",
    "explanation": "Because segments are variable-sized, free memory can become fragmented into small, unusable gaps."
  },
  {
    "id": 330,
    "topic": "Virtual Memory",
    "question": "What is the role of the 'brk' system call?",
    "options": [
      "To terminate a process",
      "To change the location of the program break (end of heap)",
      "To flush the TLB",
      "To map a file into memory"
    ],
    "answer": "To change the location of the program break (end of heap)",
    "explanation": "brk() and sbrk() adjust the heap size by moving the program break pointer, used by malloc() internally."
  },
  {
    "id": 331,
    "topic": "Virtual Memory",
    "question": "Which of the following best describes demand paging?",
    "options": [
      "All pages are loaded into memory at process startup",
      "Pages are loaded only when accessed",
      "Pages are pre-fetched based on prediction",
      "Pages are encrypted before loading"
    ],
    "answer": "Pages are loaded only when accessed",
    "explanation": "Demand paging improves memory efficiency by loading pages on first reference, not at program launch."
  },
  {
    "id": 332,
    "topic": "Virtual Memory",
    "question": "What is a page table entry (PTE)?",
    "options": [
      "A record in the file system",
      "A data structure that holds metadata for a virtual page",
      "A CPU instruction for memory access",
      "A network packet header"
    ],
    "answer": "A data structure that holds metadata for a virtual page",
    "explanation": "Each PTE contains the physical frame number, valid/invalid bit, dirty bit, and protection bits."
  },
  {
    "id": 333,
    "topic": "Virtual Memory",
    "question": "Which memory allocation strategy allocates the smallest hole that is big enough?",
    "options": [
      "First-fit",
      "Best-fit",
      "Worst-fit",
      "Next-fit"
    ],
    "answer": "Best-fit",
    "explanation": "Best-fit searches for the smallest available partition that can accommodate the request, minimizing wasted space."
  },
  {
    "id": 334,
    "topic": "Virtual Memory",
    "question": "Which of the following is true about shared memory?",
    "options": [
      "It requires copying data between processes",
      "It is slower than message passing",
      "It allows multiple processes to access the same physical memory region",
      "It is only used for kernel data"
    ],
    "answer": "It allows multiple processes to access the same physical memory region",
    "explanation": "Shared memory is the fastest IPC mechanism since it avoids data copying, but requires synchronization."
  },
  {
    "id": 335,
    "topic": "Virtual Memory",
    "question": "What does the 'mmap' system call do?",
    "options": [
      "Monitors memory usage",
      "Maps files or devices into the process’s virtual address space",
      "Measures memory bandwidth",
      "Moves memory blocks between processes"
    ],
    "answer": "Maps files or devices into the process’s virtual address space",
    "explanation": "mmap() enables file I/O via memory access, useful for shared memory and efficient large-file handling."
  },
  {
    "id": 336,
    "topic": "Virtual Memory",
    "question": "Which of the following causes external fragmentation?",
    "options": [
      "Fixed-size memory allocation",
      "Variable-size allocation with deallocation over time",
      "Using virtual memory",
      "Enabling memory protection"
    ],
    "answer": "Variable-size allocation with deallocation over time",
    "explanation": "External fragmentation results in free memory being scattered in small blocks, insufficient for new allocations."
  },
  {
    "id": 337,
    "topic": "Virtual Memory",
    "question": "What is the purpose of the 'valid' bit in a page table entry?",
    "options": [
      "Indicates if the page is encrypted",
      "Indicates if the page is currently in physical memory",
      "Marks the page as read-only",
      "Shows if the page has been modified"
    ],
    "answer": "Indicates if the page is currently in physical memory",
    "explanation": "If the valid bit is 0, accessing the page triggers a page fault to load it from disk."
  },
  {
    "id": 338,
    "topic": "Virtual Memory",
    "question": "Which of the following is a benefit of using a multilevel page table?",
    "options": [
      "Faster disk access",
      "Reduced memory overhead for sparse address spaces",
      "Elimination of page faults",
      "Automatic memory compression"
    ],
    "answer": "Reduced memory overhead for sparse address spaces",
    "explanation": "Multilevel page tables avoid allocating page table memory for unused regions of virtual address space."
  },
  {
    "id": 339,
    "topic": "Virtual Memory",
    "question": "What is copy-on-write (COW)?",
    "options": [
      "A disk backup technique",
      "A method where shared pages are copied only when written to",
      "A memory encryption protocol",
      "A CPU cache invalidation strategy"
    ],
    "answer": "A method where shared pages are copied only when written to",
    "explanation": "COW optimizes fork() by sharing parent and child pages until one modifies them, reducing memory usage."
  },
  {
    "id": 340,
    "topic": "Virtual Memory",
    "question": "Which of the following is NOT a page replacement algorithm?",
    "options": [
      "LRU",
      "FIFO",
      "SCAN",
      "Clock"
    ],
    "answer": "SCAN",
    "explanation": "SCAN is a disk scheduling algorithm, not a page replacement policy."
  },
  {
    "id": 341,
    "topic": "Virtual Memory",
    "question": "What is the working set of a process?",
    "options": [
      "The total size of the program on disk",
      "The set of pages actively used during a recent time interval",
      "The number of child processes",
      "The amount of swap space allocated"
    ],
    "answer": "The set of pages actively used during a recent time interval",
    "explanation": "The working set model helps prevent thrashing by ensuring processes have enough frames for active pages."
  },
  {
    "id": 342,
    "topic": "Virtual Memory",
    "question": "Which system call is used to deallocate memory mapped with mmap()?",
    "options": [
      "free()",
      "munmap()",
      "unmap()",
      "dealloc()"
    ],
    "answer": "munmap()",
    "explanation": "munmap() removes the mapping created by mmap(), freeing the virtual address range."
  },
  {
    "id": 343,
    "topic": "Virtual Memory",
    "question": "What is memory overcommitment?",
    "options": [
      "Allocating more virtual memory than physical RAM + swap",
      "Using more CPU than available",
      "Exceeding disk quota",
      "Running too many processes"
    ],
    "answer": "Allocating more virtual memory than physical RAM + swap",
    "explanation": "Linux allows overcommitment under the assumption that not all allocated memory will be used simultaneously."
  },
  {
    "id": 344,
    "topic": "Virtual Memory",
    "question": "Which of the following is true about the heap?",
    "options": [
      "It grows downward from high addresses",
      "It is used for static variables only",
      "It is managed automatically by the compiler",
      "It grows upward and is used for dynamic allocation"
    ],
    "answer": "It grows upward and is used for dynamic allocation",
    "explanation": "The heap expands upward from the end of the data segment and is used for malloc(), new, etc."
  },
  {
    "id": 345,
    "topic": "Virtual Memory",
    "question": "What is a memory leak?",
    "options": [
      "Physical RAM degradation over time",
      "Failure to deallocate dynamically allocated memory",
      "Unauthorized access to memory",
      "Corrupted page table entries"
    ],
    "answer": "Failure to deallocate dynamically allocated memory",
    "explanation": "Memory leaks occur when allocated memory is not freed, leading to gradual resource exhaustion."
  },
  {
    "id": 346,
    "topic": "Virtual Memory",
    "question": "Which of the following is used to reduce TLB misses?",
    "options": [
      "Smaller page sizes",
      "Larger page sizes",
      "Disabling virtual memory",
      "Using FIFO replacement"
    ],
    "answer": "Larger page sizes",
    "explanation": "Larger pages (e.g., 2MB or 1GB) cover more address space per TLB entry, reducing misses but increasing internal fragmentation."
  },
  {
    "id": 347,
    "topic": "Virtual Memory",
    "question": "What is the purpose of the 'dirty' bit in a page table entry?",
    "options": [
      "Indicates the page contains malware",
      "Indicates the page has been modified and needs to be written back to disk",
      "Marks the page as inaccessible",
      "Shows the page is shared"
    ],
    "answer": "Indicates the page has been modified and needs to be written back to disk",
    "explanation": "The dirty bit helps optimize swapping—clean pages can be discarded; dirty pages must be saved."
  },
  {
    "id": 348,
    "topic": "Virtual Memory",
    "question": "Which memory management unit (MMU) function is critical for virtual memory?",
    "options": [
      "Executing CPU instructions",
      "Translating virtual to physical addresses",
      "Managing disk partitions",
      "Handling network packets"
    ],
    "answer": "Translating virtual to physical addresses",
    "explanation": "The MMU uses page tables to perform address translation, enabling virtual memory abstraction."
  },
  {
    "id": 349,
    "topic": "Virtual Memory",
    "question": "What is the main drawback of the FIFO page replacement algorithm?",
    "options": [
      "It’s too slow to implement",
      "It can suffer from Belady’s anomaly",
      "It requires hardware support",
      "It doesn’t work with virtual memory"
    ],
    "answer": "It can suffer from Belady’s anomaly",
    "explanation": "Belady’s anomaly means increasing frames can lead to more page faults under FIFO, which is counterintuitive."
  },
  {
    "id": 350,
    "topic": "Virtual Memory",
    "question": "Which of the following is a characteristic of the stack?",
    "options": [
      "Dynamically allocated with malloc()",
      "Grows upward in memory",
      "Used for function call management and local variables",
      "Shared among all threads in a process"
    ],
    "answer": "Used for function call management and local variables",
    "explanation": "The stack stores return addresses, parameters, and local variables, growing downward with each function call."
  },
  {
    "id": 351,
    "topic": "Virtual Memory",
    "question": "What is swapping?",
    "options": [
      "Moving entire processes between RAM and disk",
      "Replacing one page with another in RAM",
      "Encrypting memory contents",
      "Compressing inactive pages"
    ],
    "answer": "Moving entire processes between RAM and disk",
    "explanation": "Swapping (in older systems) suspends a process by moving it entirely to swap space to free RAM."
  },
  {
    "id": 352,
    "topic": "Virtual Memory",
    "question": "Which of the following best describes memory protection?",
    "options": [
      "Preventing processes from accessing unauthorized memory regions",
      "Compressing memory to save space",
      "Backing up memory to cloud storage",
      "Encrypting all RAM contents"
    ],
    "answer": "Preventing processes from accessing unauthorized memory regions",
    "explanation": "Memory protection uses hardware (e.g., MMU) and OS mechanisms to enforce access rights and prevent corruption."
  },
  {
    "id": 353,
    "topic": "Virtual Memory",
    "question": "What is the role of the 'sbrk' system call?",
    "options": [
      "To change the stack size",
      "To adjust the program break for heap expansion",
      "To flush the CPU cache",
      "To synchronize memory across cores"
    ],
    "answer": "To adjust the program break for heap expansion",
    "explanation": "sbrk() increments or decrements the program break, effectively growing or shrinking the heap."
  },
  {
    "id": 354,
    "topic": "Virtual Memory",
    "question": "Which of the following is true about virtual address space?",
    "options": [
      "It is limited by physical RAM size",
      "It is the same for all processes",
      "It is private to each process and typically much larger than physical memory",
      "It cannot include memory-mapped files"
    ],
    "answer": "It is private to each process and typically much larger than physical memory",
    "explanation": "Each process has its own virtual address space, giving the illusion of large, contiguous memory."
  },
  {
    "id": 355,
    "topic": "Virtual Memory",
    "question": "What is a page directory used for?",
    "options": [
      "Storing file names",
      "Indexing disk blocks",
      "In multilevel paging, pointing to page tables",
      "Managing process priorities"
    ],
    "answer": "In multilevel paging, pointing to page tables",
    "explanation": "In x86 architecture, the page directory is the first level of a two-level page table hierarchy."
  },
  {
    "id": 356,
    "topic": "Virtual Memory",
    "question": "Which of the following reduces external fragmentation?",
    "options": [
      "Paging",
      "Segmentation",
      "Dynamic linking",
      "Shared libraries"
    ],
    "answer": "Paging",
    "explanation": "Because paging uses fixed-size blocks, it eliminates external fragmentation (though internal may remain)."
  },
  {
    "id": 357,
    "topic": "Virtual Memory",
    "question": "What is the main purpose of memory compaction?",
    "options": [
      "To compress data in RAM",
      "To combine free memory holes into larger blocks",
      "To encrypt memory contents",
      "To reduce CPU cache misses"
    ],
    "answer": "To combine free memory holes into larger blocks",
    "explanation": "Compaction moves allocated blocks to eliminate external fragmentation, but is expensive and rarely used in virtual memory systems."
  },
  {
    "id": 358,
    "topic": "Virtual Memory",
    "question": "Which of the following is a feature of slab allocation?",
    "options": [
      "Used for managing kernel object caches efficiently",
      "Replaces the need for virtual memory",
      "Allocates memory in powers of two only",
      "Is used exclusively for user-space programs"
    ],
    "answer": "Used for managing kernel object caches efficiently",
    "explanation": "Slab allocation reduces fragmentation and initialization overhead for frequently used kernel objects (e.g., inodes, PCBs)."
  },
  {
    "id": 359,
    "topic": "Virtual Memory",
    "question": "What happens when the TLB is flushed?",
    "options": [
      "All RAM is erased",
      "The CPU cache is cleared",
      "All virtual-to-physical translations are invalidated",
      "The page file is deleted"
    ],
    "answer": "All virtual-to-physical translations are invalidated",
    "explanation": "TLB flush occurs during context switches or page table changes, causing subsequent memory accesses to miss until reloaded."
  },
  {
    "id": 360,
    "topic": "Virtual Memory",
    "question": "What is the primary difference between virtual and physical memory?",
    "options": [
      "Virtual memory is faster",
      "Physical memory is managed by the OS; virtual memory by the CPU",
      "Virtual memory is an abstraction; physical memory is actual RAM",
      "They are the same thing"
    ],
    "answer": "Virtual memory is an abstraction; physical memory is actual RAM",
    "explanation": "Virtual memory provides each process with its own address space, mapped to physical RAM by the OS and MMU."
  },
  {
    "id": 361,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism allows unrelated processes to communicate?",
    "options": [
      "Pipes",
      "Message queues",
      "Shared memory",
      "Both B and C"
    ],
    "answer": "Both B and C",
    "explanation": "Named pipes, message queues, and shared memory (with proper setup) can be used by unrelated processes; anonymous pipes require parent-child relationship."
  },
  {
    "id": 362,
    "topic": "Interprocess Communication",
    "question": "What is the main advantage of shared memory over message passing?",
    "options": [
      "Better security",
      "Faster data transfer (no kernel copying)",
      "Easier synchronization",
      "Automatic serialization"
    ],
    "answer": "Faster data transfer (no kernel copying)",
    "explanation": "Shared memory avoids data copying between processes, making it the fastest IPC method, though it requires explicit synchronization."
  },
  {
    "id": 363,
    "topic": "Interprocess Communication",
    "question": "Which of the following is a characteristic of message passing?",
    "options": [
      "Requires shared address space",
      "Involves kernel-mediated data transfer",
      "Is always faster than shared memory",
      "Cannot be used over a network"
    ],
    "answer": "Involves kernel-mediated data transfer",
    "explanation": "Message passing (e.g., sockets, message queues) copies data through the kernel, providing isolation but with overhead."
  },
  {
    "id": 364,
    "topic": "Interprocess Communication",
    "question": "What is a pipe in Unix systems?",
    "options": [
      "A hardware device for I/O",
      "A unidirectional data channel for IPC between related processes",
      "A type of shared memory",
      "A network protocol"
    ],
    "answer": "A unidirectional data channel for IPC between related processes",
    "explanation": "Pipes (created with pipe()) are typically used between parent and child processes, with data flowing in one direction."
  },
  {
    "id": 365,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism is best suited for communication between processes on different machines?",
    "options": [
      "Shared memory",
      "Pipes",
      "Sockets",
      "Semaphores"
    ],
    "answer": "Sockets",
    "explanation": "Sockets support network communication and can be used for both local and remote IPC."
  },
  {
    "id": 366,
    "topic": "Interprocess Communication",
    "question": "What is the purpose of a semaphore in IPC?",
    "options": [
      "To transfer large data blocks",
      "To synchronize access to shared resources",
      "To compress messages",
      "To encrypt data"
    ],
    "answer": "To synchronize access to shared resources",
    "explanation": "Semaphores are counters used to control access to critical sections, preventing race conditions."
  },
  {
    "id": 367,
    "topic": "Interprocess Communication",
    "question": "Which of the following is true about named pipes (FIFOs)?",
    "options": [
      "They exist only in memory",
      "They appear as special files in the file system",
      "They are faster than anonymous pipes",
      "They cannot be used by unrelated processes"
    ],
    "answer": "They appear as special files in the file system",
    "explanation": "Named pipes (created with mkfifo) have a file system entry and can be accessed by any process with appropriate permissions."
  },
  {
    "id": 368,
    "topic": "Interprocess Communication",
    "question": "What is a mutex?",
    "options": [
      "A type of message queue",
      "A binary semaphore used for mutual exclusion",
      "A network socket type",
      "A memory allocation strategy"
    ],
    "answer": "A binary semaphore used for mutual exclusion",
    "explanation": "A mutex ensures that only one thread or process can enter a critical section at a time."
  },
  {
    "id": 369,
    "topic": "Interprocess Communication",
    "question": "Which system call is used to create a message queue in POSIX systems?",
    "options": [
      "msgget()",
      "mq_open()",
      "queue_create()",
      "ipc_msg()"
    ],
    "answer": "mq_open()",
    "explanation": "POSIX message queues use mq_open() to create or open a queue; System V uses msgget()."
  },
  {
    "id": 370,
    "topic": "Interprocess Communication",
    "question": "What is the main disadvantage of shared memory?",
    "options": [
      "High kernel overhead",
      "Requires explicit synchronization to avoid race conditions",
      "Cannot be used locally",
      "Slower than message passing"
    ],
    "answer": "Requires explicit synchronization to avoid race conditions",
    "explanation": "Because shared memory lacks built-in synchronization, programmers must use semaphores, mutexes, etc."
  },
  {
    "id": 371,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism provides automatic synchronization?",
    "options": [
      "Shared memory",
      "Message passing",
      "Memory-mapped files",
      "Signals"
    ],
    "answer": "Message passing",
    "explanation": "Message passing (e.g., sockets, queues) handles synchronization implicitly—sending blocks if buffer is full; receiving blocks if empty."
  },
  {
    "id": 372,
    "topic": "Interprocess Communication",
    "question": "What is a signal in Unix IPC?",
    "options": [
      "A method for transferring large data",
      "A software interrupt notifying a process of an event",
      "A type of shared memory",
      "A network packet"
    ],
    "answer": "A software interrupt notifying a process of an event",
    "explanation": "Signals (e.g., SIGINT, SIGKILL) are asynchronous notifications used for process control and error handling."
  },
  {
    "id": 373,
    "topic": "Interprocess Communication",
    "question": "Which of the following is true about sockets?",
    "options": [
      "They only work on the same machine",
      "They support both connection-oriented (TCP) and connectionless (UDP) communication",
      "They are slower than all other IPC methods",
      "They cannot be used for local IPC"
    ],
    "answer": "They support both connection-oriented (TCP) and connectionless (UDP) communication",
    "explanation": "Sockets are versatile, supporting local (Unix domain) and network (Internet domain) communication with various protocols."
  },
  {
    "id": 374,
    "topic": "Interprocess Communication",
    "question": "What is the purpose of the 'shmget' system call?",
    "options": [
      "To get a shared memory segment identifier",
      "To send a message to a queue",
      "To create a pipe",
      "To allocate a socket"
    ],
    "answer": "To get a shared memory segment identifier",
    "explanation": "shmget() is part of System V shared memory API, returning an identifier for a shared memory segment."
  },
  {
    "id": 375,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism is typically used for producer-consumer problems?",
    "options": [
      "Shared memory with semaphores",
      "Signals",
      "Pipes",
      "All of the above"
    ],
    "answer": "All of the above",
    "explanation": "Producer-consumer can be implemented with shared memory + semaphores, pipes (kernel buffers), or message queues."
  },
  {
    "id": 376,
    "topic": "Interprocess Communication",
    "question": "What is a race condition in IPC?",
    "options": [
      "Two processes competing for CPU time",
      "Unpredictable behavior due to uncontrolled access to shared data",
      "A deadlock between two processes",
      "A process exceeding its time slice"
    ],
    "answer": "Unpredictable behavior due to uncontrolled access to shared data",
    "explanation": "Race conditions occur when the outcome depends on the timing of uncontrollable events, often leading to data corruption."
  },
  {
    "id": 377,
    "topic": "Interprocess Communication",
    "question": "Which of the following is a benefit of using message queues over pipes?",
    "options": [
      "Message queues preserve message boundaries",
      "Pipes are persistent; queues are not",
      "Queues are unidirectional",
      "Pipes support priorities"
    ],
    "answer": "Message queues preserve message boundaries",
    "explanation": "In pipes, data is a byte stream; in message queues, each message is a distinct unit with optional priorities."
  },
  {
    "id": 378,
    "topic": "Interprocess Communication",
    "question": "What is the main difference between System V and POSIX IPC?",
    "options": [
      "System V is newer",
      "POSIX IPC uses file descriptor-like handles; System V uses integer IDs",
      "System V doesn’t support shared memory",
      "POSIX is only for Windows"
    ],
    "answer": "POSIX IPC uses file descriptor-like handles; System V uses integer IDs",
    "explanation": "POSIX IPC (e.g., mq_open, shm_open) integrates better with standard I/O and is more modern; System V is older but widely supported."
  },
  {
    "id": 379,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism is most suitable for broadcasting a message to multiple processes?",
    "options": [
      "Pipes",
      "Shared memory",
      "Message queues",
      "Signals"
    ],
    "answer": "Signals",
    "explanation": "Signals can be sent to a process group, effectively broadcasting to multiple processes (though limited in data)."
  },
  {
    "id": 380,
    "topic": "Interprocess Communication",
    "question": "What is the role of 'ftok' in System V IPC?",
    "options": [
      "To create a shared memory segment",
      "To generate a unique key from a file path and ID",
      "To send a message",
      "To allocate a semaphore"
    ],
    "answer": "To generate a unique key from a file path and ID",
    "explanation": "ftok() creates a System V IPC key based on a file’s inode and a user-provided ID, ensuring uniqueness."
  },
  {
    "id": 381,
    "topic": "Interprocess Communication",
    "question": "Which of the following is true about Unix domain sockets?",
    "options": [
      "They use IP addresses",
      "They are slower than Internet sockets",
      "They are used for local IPC and use file system paths as addresses",
      "They cannot stream data"
    ],
    "answer": "They are used for local IPC and use file system paths as addresses",
    "explanation": "Unix domain sockets provide efficient local communication without network protocol overhead."
  },
  {
    "id": 382,
    "topic": "Interprocess Communication",
    "question": "What is the main purpose of a condition variable?",
    "options": [
      "To transfer data between processes",
      "To allow threads to wait for a specific condition to become true",
      "To encrypt IPC messages",
      "To allocate shared memory"
    ],
    "answer": "To allow threads to wait for a specific condition to become true",
    "explanation": "Condition variables are used with mutexes to block threads until a predicate changes, common in producer-consumer scenarios."
  },
  {
    "id": 383,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism requires the least kernel involvement after setup?",
    "options": [
      "Pipes",
      "Message queues",
      "Shared memory",
      "Sockets"
    ],
    "answer": "Shared memory",
    "explanation": "Once mapped, shared memory access is direct RAM reads/writes, with no system calls needed for data transfer."
  },
  {
    "id": 384,
    "topic": "Interprocess Communication",
    "question": "What is a mailbox in IPC?",
    "options": [
      "A type of pipe",
      "A message queue associated with a process",
      "A shared memory segment",
      "A network email system"
    ],
    "answer": "A message queue associated with a process",
    "explanation": "In some systems (e.g., Windows, some RTOS), mailboxes are per-process message queues for asynchronous communication."
  },
  {
    "id": 385,
    "topic": "Interprocess Communication",
    "question": "Which of the following is a disadvantage of using signals for IPC?",
    "options": [
      "They are too fast",
      "They can carry only limited information and are asynchronous",
      "They require shared memory",
      "They cannot be blocked"
    ],
    "answer": "They can carry only limited information and are asynchronous",
    "explanation": "Signals are not suitable for transferring data; they’re best for notifications, and their asynchrony can complicate handling."
  },
  {
    "id": 386,
    "topic": "Interprocess Communication",
    "question": "What is the purpose of 'shm_open' in POSIX IPC?",
    "options": [
      "To open a shared memory object",
      "To send a shared message",
      "To create a semaphore",
      "To allocate a pipe"
    ],
    "answer": "To open a shared memory object",
    "explanation": "shm_open() creates or opens a POSIX shared memory object, which can then be mapped with mmap()."
  },
  {
    "id": 387,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism is most appropriate for real-time systems with predictable latency?",
    "options": [
      "Sockets",
      "Message queues",
      "Shared memory with spinlocks",
      "Pipes"
    ],
    "answer": "Shared memory with spinlocks",
    "explanation": "Shared memory avoids kernel overhead, and spinlocks (though CPU-intensive) provide bounded wait times, suitable for real-time needs."
  },
  {
    "id": 388,
    "topic": "Interprocess Communication",
    "question": "What is the main difference between a pipe and a FIFO?",
    "options": [
      "Pipes are bidirectional; FIFOs are unidirectional",
      "Pipes exist only during process lifetime; FIFOs persist in the file system",
      "FIFOs are faster than pipes",
      "Pipes require root privileges"
    ],
    "answer": "Pipes exist only during process lifetime; FIFOs persist in the file system",
    "explanation": "Anonymous pipes are temporary and require parent-child relationship; FIFOs (named pipes) are persistent file system objects."
  },
  {
    "id": 389,
    "topic": "Interprocess Communication",
    "question": "Which system call is used to attach a shared memory segment to a process’s address space?",
    "options": [
      "shmat()",
      "shmget()",
      "shmdt()",
      "shmctl()"
    ],
    "answer": "shmat()",
    "explanation": "shmat() (shared memory attach) maps a System V shared memory segment into the calling process’s virtual memory."
  },
  {
    "id": 390,
    "topic": "Interprocess Communication",
    "question": "What is the purpose of the 'sem_wait' function?",
    "options": [
      "To create a semaphore",
      "To decrement (acquire) a semaphore, blocking if necessary",
      "To destroy a semaphore",
      "To get semaphore value"
    ],
    "answer": "To decrement (acquire) a semaphore, blocking if necessary",
    "explanation": "sem_wait() is used to enter a critical section; if the semaphore value is zero, the caller blocks until it becomes positive."
  },
  {
    "id": 391,
    "topic": "Interprocess Communication",
    "question": "Which of the following is true about message queues in POSIX?",
    "options": [
      "They are identified by integer IDs",
      "They appear as files in /dev/mqueue",
      "They cannot set message priorities",
      "They are slower than System V queues"
    ],
    "answer": "They appear as files in /dev/mqueue",
    "explanation": "POSIX message queues are represented as files in the virtual file system, allowing inspection with standard tools."
  },
  {
    "id": 392,
    "topic": "Interprocess Communication",
    "question": "What is the main advantage of using sockets for local IPC?",
    "options": [
      "They are the fastest method",
      "They provide a uniform API for local and network communication",
      "They require no synchronization",
      "They use less memory"
    ],
    "answer": "They provide a uniform API for local and network communication",
    "explanation": "Applications can use the same socket code for both local and remote communication, simplifying development."
  },
  {
    "id": 393,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism is best for transferring large amounts of data efficiently between local processes?",
    "options": [
      "Signals",
      "Pipes",
      "Shared memory",
      "Message queues"
    ],
    "answer": "Shared memory",
    "explanation": "Shared memory avoids data copying, making it ideal for high-bandwidth local IPC."
  },
  {
    "id": 394,
    "topic": "Interprocess Communication",
    "question": "What is the role of 'mq_send' in POSIX message queues?",
    "options": [
      "To receive a message",
      "To send a message to a queue",
      "To create a queue",
      "To delete a queue"
    ],
    "answer": "To send a message to a queue",
    "explanation": "mq_send() places a message of specified size and priority into the designated message queue."
  },
  {
    "id": 395,
    "topic": "Interprocess Communication",
    "question": "Which of the following is a synchronization primitive, not a data transfer mechanism?",
    "options": [
      "Pipe",
      "Socket",
      "Semaphore",
      "Shared memory"
    ],
    "answer": "Semaphore",
    "explanation": "Semaphores control access to resources but do not transfer data; the others are data transfer IPC methods."
  },
  {
    "id": 396,
    "topic": "Interprocess Communication",
    "question": "What is the main purpose of the 'select' system call in socket IPC?",
    "options": [
      "To choose the fastest network interface",
      "To monitor multiple file descriptors for I/O readiness",
      "To encrypt socket data",
      "To allocate socket buffers"
    ],
    "answer": "To monitor multiple file descriptors for I/O readiness",
    "explanation": "select() allows a process to wait for activity on multiple sockets or pipes without blocking on any single one."
  },
  {
    "id": 397,
    "topic": "Interprocess Communication",
    "question": "Which IPC mechanism is inherently connection-oriented?",
    "options": [
      "UDP sockets",
      "Named pipes",
      "TCP sockets",
      "Signals"
    ],
    "answer": "TCP sockets",
    "explanation": "TCP establishes a connection before data transfer, ensuring reliable, ordered delivery; UDP is connectionless."
  },
  {
    "id": 398,
    "topic": "Interprocess Communication",
    "question": "What is a critical section in IPC?",
    "options": [
      "A part of code that handles fatal errors",
      "A segment of code that accesses shared resources and must not be concurrently executed",
      "The kernel’s main scheduling loop",
      "A memory region reserved for system crashes"
    ],
    "answer": "A segment of code that accesses shared resources and must not be concurrently executed",
    "explanation": "Critical sections require mutual exclusion to prevent data inconsistency during concurrent access."
  },
  {
    "id": 399,
    "topic": "Interprocess Communication",
    "question": "Which of the following is true about memory-mapped files for IPC?",
    "options": [
      "They are slower than regular file I/O",
      "They allow processes to share data by mapping the same file into memory",
      "They cannot be used for synchronization",
      "They require root privileges"
    ],
    "answer": "They allow processes to share data by mapping the same file into memory",
    "explanation": "Memory-mapped files (via mmap) enable efficient shared memory IPC, especially for large, persistent data sets."
  },
  {
    "id": 400,
    "topic": "Interprocess Communication",
    "question": "What is the primary challenge in designing IPC mechanisms?",
    "options": [
      "Maximizing CPU utilization",
      "Balancing performance, complexity, and safety",
      "Reducing disk fragmentation",
      "Increasing network bandwidth"
    ],
    "answer": "Balancing performance, complexity, and safety",
    "explanation": "IPC must be fast (performance), easy to use correctly (complexity), and prevent errors like race conditions (safety)."
  }
]